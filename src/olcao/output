1c1
< module O_IntegralsPSCF
---
> subroutine intgAndMom (potCoeffs,calcMomentum)
3,5c3,8
<    ! Import necessary modules.
<    use O_Kinds
<    use O_Constants
---
>    ! Import the necessary modules
>    use olcao_kinds
>    use constants
>    use derived_types
> 
>    ! Import the necessary HDF data
6a10
>    use HDF5IntgDataModule
8,9c12,15
<    ! Define access
<    public
---
>    ! Import the necessary interfaces
>    use initAtomInterface
>    use findLattVecInterface
>    use genMatrixInterface
11,13c17,23
<    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<    ! Begin list of module data.!
<    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---
>    ! Import the necessary data modules
>    use CrystalDataModule
>    use TypesDataModule
>    use WaveFnDataModule
>    use ProbeDataModule
>    use RealSuperLattDataModule
>    use LattFinderDataModule
15c25
<    ! Make sure that no funny variables are defined.
---
>    ! Make sure that there are not accidental variable declarations.
18,24d27
<    ! Structures that will hold the results from many iterations of the atom-
<    !   lattice loops accumulations.
<    real (kind=double), allocatable, dimension (:,:)   :: accumulatedOL
<    real (kind=double), allocatable, dimension (:,:)   :: accumulatedMomX
<    real (kind=double), allocatable, dimension (:,:)   :: accumulatedMomY
<    real (kind=double), allocatable, dimension (:,:)   :: accumulatedMomZ
<    real (kind=double), allocatable, dimension (:,:,:) :: accumulatedHam
26,28c29,31
<    ! Structure that will track the indices of the loops for the above data.
<    integer, allocatable, dimension (:,:) :: loopIndices
<    integer, allocatable, dimension (:,:) :: currentLoopIndices
---
>    ! Define the data structure variables passed to this subroutine
>    real (kind=double), dimension (:,:) :: potCoeffs
>    integer :: calcMomentum
30,32d32
<    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<    ! Begin list of module subroutines.!
<    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
34,59d33
< contains
< 
< subroutine intgAndOrMom(doINTG)
< 
<    ! Import necessary modules.
<    use O_Kinds
<    use O_Constants
<    use O_TimeStamps
<    use O_CommandLine
<    use O_Potential
<    use O_Basis
<    use O_Lattice
<    use O_PotTypes
<    use O_PotSites
<    use O_AtomicSites
<    use O_AtomicTypes
<    use O_GaussianIntegrals
<    use O_PSCFIntgHDF5
<    use HDF5
< 
<    ! Make sure that there are not accidental variable declarations.
<    implicit none
< 
<    ! Define passed parameters.
<    integer :: doINTG  ! (1) = do overlap & hamiltonian integrals; (0) = do not.
< 
60a35,37
>    character*30 :: currentName
>    character*8  :: date
>    character*10 :: time
82c59
<    real (kind=double), allocatable, dimension (:,:,:) :: currentBasisFns
---
>    real (kind=double), allocatable, dimension (:,:,:) :: currentWaveFns
201a179,197
>    interface
>       subroutine initAtomHDF (i, calcMomentum)
>          use HDF5
>          use HDF5IntgDataModule
>          integer :: i
>          integer :: calcMomentum
>       end subroutine initAtomHDF
>       subroutine saveCurrentAccumulation (calcMomentum,maxNumStates)
>          use HDF5
>          use HDF5IntgDataModule
>          integer :: calcMomentum
>          integer :: maxNumStates
>       end subroutine saveCurrentAccumulation
>       subroutine closeAtomHDF (calcMomentum)
>          use HDF5
>          use HDF5IntgDataModule
>          integer :: calcMomentum
>       end subroutine closeAtomHDF
>    end interface
203,204d198
<    ! Log the date and time we start.
<    call timeStampStart(20)
205a200,201
>    write (20,*) '***************************************************'
>    write (20,*) '****  Begin All Integrals and Momentum Matrix  ****'
206a203,207
>    ! Log the date and time we start.
>    call date_and_time(date,time)
>    write (20,100) date,time
>    call flush (20)
> 
208c209
<    allocate (currentBasisFns       (maxNumAtomAlphas,maxNumStates,2))
---
>    allocate (currentWaveFns        (maxNumAtomAlphas,maxNumStates,2))
213a215,218
>    allocate (pairXWaveFn2OL        (16,maxNumAtomAlphas,maxNumStates))
>    allocate (pairXWaveFn2Ham       (16,maxNumAtomAlphas,maxNumStates,spin))
>    allocate (pairXWaveFn12OL       (maxNumStates,maxNumStates))
>    allocate (pairXWaveFn12Ham      (maxNumStates,maxNumStates,spin))
215,219c220,226
< !   if (doINTG == 1) then
<       allocate (pairXWaveFn2OL     (16,maxNumAtomAlphas,maxNumStates))
<       allocate (pairXWaveFn2Ham    (16,maxNumAtomAlphas,maxNumStates,spin))
<       allocate (pairXWaveFn12OL    (maxNumStates,maxNumStates))
<       allocate (pairXWaveFn12Ham   (maxNumStates,maxNumStates,spin))
---
>    if (calcMomentum == 1) then
>       allocate (pairXWaveFn2MomX   (16,maxNumAtomAlphas,maxNumStates))
>       allocate (pairXWaveFn2MomY   (16,maxNumAtomAlphas,maxNumStates))
>       allocate (pairXWaveFn2MomZ   (16,maxNumAtomAlphas,maxNumStates))
>       allocate (pairXWaveFn12MomX  (maxNumStates,maxNumStates))
>       allocate (pairXWaveFn12MomY  (maxNumStates,maxNumStates))
>       allocate (pairXWaveFn12MomZ  (maxNumStates,maxNumStates))
221,224c228,232
<       ! Initialize overlap and hamiltonian matrices.
<       pairXWaveFn12OL(:,:)    = 0.0_double
<       pairXWaveFn12Ham(:,:,:) = 0.0_double
< !   endif
---
>       ! Initialize matrices
>       pairXWaveFn12MomX = 0.0_double
>       pairXWaveFn12MomY = 0.0_double
>       pairXWaveFn12MomZ = 0.0_double
>    endif
226,238c234,236
< !   if (doMOME == 1) then
< !      allocate (pairXWaveFn2MomX   (16,maxNumAtomAlphas,maxNumStates))
< !      allocate (pairXWaveFn2MomY   (16,maxNumAtomAlphas,maxNumStates))
< !      allocate (pairXWaveFn2MomZ   (16,maxNumAtomAlphas,maxNumStates))
< !      allocate (pairXWaveFn12MomX  (maxNumStates,maxNumStates))
< !      allocate (pairXWaveFn12MomY  (maxNumStates,maxNumStates))
< !      allocate (pairXWaveFn12MomZ  (maxNumStates,maxNumStates))
< !
< !      ! Initialize momentum matrix element matrices.
< !      pairXWaveFn12MomX(:,:) = 0.0_double
< !      pairXWaveFn12MomY(:,:) = 0.0_double
< !      pairXWaveFn12MomZ(:,:) = 0.0_double
< !   endif
---
>    ! Initialize certain matrices.
>    pairXWaveFn12OL  = 0.0_double
>    pairXWaveFn12Ham = 0.0_double
254,255c252
<    ! Initialize other variables.
<    exactFit = 0
---
>    do i = 1, numAtoms
257,258d253
<    do i = 1, numAtomSites
< 
260c255
<       call initAtomHDF (i,doINTG)
---
>       call initAtomHDF (i,calcMomentum)
264c259
<       call initializeAtomSite(i,1,currentAtomType,currentElements,&
---
>       call initializeAtom(i,1,currentAtomType,currentElements,&
267c262
<             & currentPosition,currentAlphas,currentBasisFns)
---
>             & currentPosition,currentAlphas,currentWaveFns)
270c265
<       do j = i, numAtomSites
---
>       do j = i, numAtoms
274c269
<          call initializeAtomSite(j,2,currentAtomType,currentElements,&
---
>          call initializeAtom(j,2,currentAtomType,currentElements,&
277c272
<             & currentPosition,currentAlphas,currentBasisFns)
---
>             & currentPosition,currentAlphas,currentWaveFns)
285c280
<                & latticeVector)
---
>                & latticeVector,cellDimsReal,realVectors)
293c288
<          currentNegligLimit = logBasisFnThresh * (currentAlphas(1,1) + &
---
>          currentNegligLimit = logWaveFnThresh * (currentAlphas(1,1) + &
346c341
<             alphaDist(:currentNumAlphas(1),k) = logBasisFnThresh / &
---
>             alphaDist(:currentNumAlphas(1),k) = logWaveFnThresh / &
374,376c369,375
<             !    times the atom2 wave functions.
< !            if (doINTG == 1) then
<                pairXWaveFn2OL(:,:currentNumAlphas(1),&
---
>             ! times the atom2 wave functions.
>             pairXWaveFn2OL(:,:currentNumAlphas(1),&
>                   &:currentNumTotalStates(2)) = 0.0_double
>             pairXWaveFn2Ham(:,:currentNumAlphas(1),&
>                   &:currentNumTotalStates(2),:spin) = 0.0_double
>             if (calcMomentum == 1) then
>                pairXWaveFn2MomX(:,:currentNumAlphas(1),&
378,388c377,381
<                pairXWaveFn2Ham(:,:currentNumAlphas(1),&
<                      &:currentNumTotalStates(2),:spin) = 0.0_double
< !            endif
< !            if (doMOME == 1) then
< !               pairXWaveFn2MomX(:,:currentNumAlphas(1),&
< !                     &:currentNumTotalStates(2)) = 0.0_double
< !               pairXWaveFn2MomY(:,:currentNumAlphas(1),&
< !                     &:currentNumTotalStates(2)) = 0.0_double
< !               pairXWaveFn2MomZ(:,:currentNumAlphas(1),&
< !                     &:currentNumTotalStates(2)) = 0.0_double
< !            endif
---
>                pairXWaveFn2MomY(:,:currentNumAlphas(1),&
>                      &:currentNumTotalStates(2)) = 0.0_double
>                pairXWaveFn2MomZ(:,:currentNumAlphas(1),&
>                      &:currentNumTotalStates(2)) = 0.0_double
>             endif
466,469c459,461
< !                  if (doINTG == 1) then
<                      ! At this point a sufficient overlap has been found for
<                      !   the current alpha pair so we start looking through
<                      !   nuclear potentials.
---
>                   ! At this point a sufficient overlap has been found for the
>                   !   current alpha pair so we start looking through nuclear
>                   !   potentials.
471,476c463,467
<                      ! First we find the center of the overlap between the two
<                      !   alphas.
<                      overlapCenter(:) = &
<                            & alphaCenter(alphaIndex(1),alphaIndex(2)) * &
<                            & (currentPosition(:,1) - shiftedAtomPos(:)) + &
<                            & shiftedAtomPos(:)
---
>                   ! First we find the center of the overlap between the two
>                   !   alphas.
>                   overlapCenter(:) = alphaCenter(alphaIndex(1),alphaIndex(2)) *&
>                         & (currentPosition(:,1) - shiftedAtomPos(:)) + &
>                         & shiftedAtomPos(:)
478,482c469,473
<                      ! Initialize the result matrix to zero before starting the
<                      !   nuclear potential loop.
<                      potAtomOverlap(:currentlmAlphaIndex(alphaIndex(1),1), &
<                            & :currentlmAlphaIndex(alphaIndex(2),2),:spin) = &
<                            & 0.0_double
---
>                   ! Initialize the result matrix to zero before starting the
>                   !   nuclear potential loop.
>                   potAtomOverlap(:currentlmAlphaIndex(alphaIndex(1),1), &
>                         & :currentlmAlphaIndex(alphaIndex(2),2),:spin) = &
>                         & 0.0_double
485,487c476,478
<                      ! Initialize a counter to track which potential
<                      !    coefficient we are currently calculating on.
<                      potCoeffIndex = 0
---
>                   ! Initialize a counter to track which potential coefficient
>                   !    we are currently calculating on.
>                   potCoeffIndex = 0
489,491c480,482
<                      ! Initiate a loop over each potential site for the nuclear
<                      !   potentials.
<                      do m = 1, numPotSites
---
>                   ! Initiate a loop over each potential site for the nuclear
>                   !   potentials.
>                   do m = 1, numPots
493,496c484,485
<                         ! Skip equivalent types now.  THey will be accounted
<                         !   for later but we want to do some setup stuff only
<                         !   once for all atoms of the same type.
<                         if (potSites(m)%firstPotType == 0) cycle
---
>                      ! Skip equivalent types
>                      if (potData(m)%equivalence /= 0) cycle
498,501c487,490
<                         ! Initialize the parameters for this potential site
<                         !   related to the type of this site.
<                         currentPotType = potSites(m)%potTypeAssn
<                         currentNumPotAlphas = potTypes(currentPotType)%numAlphas
---
>                      ! Initialize the parameters for this potential site
>                      !   related to the type of this site.
>                      currentPotType = potData(m)%potTypeAssn
>                      currentNumPotAlphas = potTypes(currentPotType)%numAlphas
503,505c492,494
<                         ! Initiate a loop over all the potential alphas present
<                         !   for this site including the nuclear contribution.
<                         do n = 1, currentNumPotAlphas + 1
---
>                      ! Initiate a loop over all the potential alphas present
>                      !   for this site including the nuclear contribution.
>                      do n = 1, currentNumPotAlphas + 1
507,508c496,497
<                            ! Assign the potential alpha based on the value of n.
<                            if (n <= currentNumPotAlphas) then
---
>                         ! Assign the potential alpha based on the value of n.
>                         if (n <= currentNumPotAlphas) then
510c499
<                               ! Apply the case for the atomic potential.
---
>                            ! Apply the case for the atomic potential.
512,515c501,504
<                               ! Increment the index value that indicates which
<                               !   potential coefficient to use of all
<                               !   coefficients in the system.
<                               potCoeffIndex = potCoeffIndex + 1
---
>                            ! Increment the index value that indicates which
>                            !   potential coefficient to use of all coefficients
>                            !   in the system.
>                            potCoeffIndex = potCoeffIndex + 1
517,519c506,508
<                               ! Store the current potential coefficient.
<                               currentPotCoeff(:spin) = &
<                                     & potCoeffs(potCoeffIndex,:spin)
---
>                            ! Store the current potential coefficient.
>                            currentPotCoeff(:spin) = &
>                                  & potCoeffs(potCoeffIndex,:spin)
521,524c510,512
<                               ! Store the current potential alpha. 
<                               currentPotAlpha = &
<                                     & potTypes(currentPotType)%alphas(n)
<                            else
---
>                            ! Store the current potential alpha. 
>                            currentPotAlpha = potTypes(currentPotType)%alphas(n)
>                         else
526c514
<                               ! Apply the case for the nuclear potential.
---
>                            ! Apply the case for the nuclear potential.
528,529c516,517
<                               ! Get nuclear charge associated with this type.
<                               zFactor = potTypes(currentPotType)%nucCharge
---
>                            ! Get the nuclear charge associated with this type.
>                            zFactor = potTypes(currentPotType)%nuclearCharge
531,534c519,522
<                               ! If the zFactor is sufficiently small we
<                               !   consider the effect of the overlap to be
<                               !   negligable and we cycle to the next one.
<                               if (zFactor < smallThresh) cycle
---
>                            ! If the zFactor is sufficiently small we consider
>                            !   the effect of the overlap to be negligable and
>                            !   we cycle to the next one.
>                            if (zFactor < smallThresh) cycle
536,539c524,526
<                               ! Get the exponential alpha factor for the
<                               !   nuclear potential.
<                               currentPotAlpha = &
<                                     & potTypes(currentPotType)%nucAlpha
---
>                            ! Get the exponential alpha factor for the nuclear
>                            !   potential.
>                            currentPotAlpha = potTypes(currentPotType)%alpha
541c528
<                            endif
---
>                         endif
543,554c530,541
<                            ! Determine the maximum distance beyond which the
<                            !   overlap of the three gaussians is considered
<                            !   negligable.
<                            threeAlphaDist = logBasisFnThresh * (1 - &
<                                  & shiftedAtomSiteSep / &
<                                  & alphaDist(alphaIndex(1),alphaIndex(2))) * &
<                                  & (currentAlphas(alphaIndex(1),1) + &
<                                  &  currentAlphas(alphaIndex(2),2) + &
<                                  &  currentPotAlpha) / &
<                                  & (currentAlphas(alphaIndex(1),1) + &
<                                  &  currentAlphas(alphaIndex(2),2)) / &
<                                  &  currentPotAlpha
---
>                         ! Determine the maximum distance beyond which the
>                         !   overlap of the three gaussians is considered
>                         !   negligable.
>                         threeAlphaDist = logWaveFnThresh * (1 - &
>                               & shiftedAtomSiteSep / &
>                               & alphaDist(alphaIndex(1),alphaIndex(2))) * &
>                               & (currentAlphas(alphaIndex(1),1) + &
>                               &  currentAlphas(alphaIndex(2),2) + &
>                               &  currentPotAlpha) / &
>                               & (currentAlphas(alphaIndex(1),1) + &
>                               &  currentAlphas(alphaIndex(2),2)) / &
>                               &  currentPotAlpha
556,558c543,545
<                            ! Loop over the remaining potential sites that are
<                            !   equivalent.
<                            do o = 0, potTypes(currentPotType)%multiplicity-1
---
>                         ! Loop over the remaining potential sites that are
>                         !   equivalent.
>                         do o = 0, potTypes(currentPotType)%multiplicity-1
560,562c547,549
<                               ! Initialize the parameters for this potential
<                               !   site related to its position.
<                               potPosition(:) = potSites(m+o)%cartPos(:)
---
>                            ! Initialize the parameters for this potential site
>                            !   related to its position.
>                            potPosition(:) = potData(m+o)%position(:)
564,566c551,554
<                               ! Locate the origin for the potential lattice sum.
<                               call findLatticeVector((overlapCenter(:) - &
<                                     & potPosition(:)), latticeVector2)
---
>                            ! Locate the origin for the potential lattice sum.
>                            call findLatticeVector((overlapCenter(:) - &
>                                  & potPosition(:)), latticeVector2, &
>                                  & cellDimsReal,realVectors)
568,572c556,560
<                               ! Find the seperation vector and distance between
<                               !   the minimum overlap center, and the origin.
<                               centerOriginVect(:) = overlapCenter(:) - &
<                                     & potPosition(:) - latticeVector2(:)
<                               centerOriginSep = sum(centerOriginVect(:)**2)
---
>                            ! Find the seperation vector and distance between the
>                            !   minimum overlap center, and the origin.
>                            centerOriginVect(:) = overlapCenter(:) - &
>                                  & potPosition(:) - latticeVector2(:)
>                            centerOriginSep = sum(centerOriginVect(:)**2)
574,575c562,563
<                               ! Check if largest potential is negligable or not.
<                               if (centerOriginSep > threeAlphaDist) cycle
---
>                            ! Check if largest potential is negligable or not.
>                            if (centerOriginSep > threeAlphaDist) cycle
577,578c565,566
<                               ! At this point it must be the case that at least
<                               !   one contribution will be calculated.
---
>                            ! At this point it must be the case that at least one
>                            !   contribution will be calculated.
580,584c568,572
<                               ! First, find the cut-off radius for the potential
<                               !   lattice summation by the triangle inequality.
<                               maxLatticeRadius2 = centerOriginSep + &
<                                  & threeAlphaDist + 2.0_double * &
<                                  & sqrt (centerOriginSep * threeAlphaDist)
---
>                            ! First, find the cut-off radius for the potential
>                            !   lattice summation by the triangle inequality.
>                            maxLatticeRadius2 = centerOriginSep + &
>                               & threeAlphaDist + 2.0_double * &
>                               & sqrt (centerOriginSep * threeAlphaDist)
587,588c575,576
<                               ! Begin loop over lattice points for the site pot.
<                               do p = 1, numCellsReal
---
>                            ! Begin a loop over lattice points for the site pot.
>                            do p = 1, numCellsReal
590,592c578,580
<                                  ! Check if this lattice point extends beyond
<                                  !   the range of negligability
<                                  if (cellSizesReal(p) > maxLatticeRadius2) exit
---
>                               ! Check if this lattice point extends beyond the
>                               !   range of negligability
>                               if (cellSizesReal(p) > maxLatticeRadius2) exit
594,597c582,585
<                                  ! Get overlap center shifted by lattice point.
<                                  shiftedCenterOriginSep = &
<                                        & sum((centerOriginVect(:) - &
<                                        & cellDimsReal(:,p))**2)
---
>                               ! Get overlap center shifted by the lattice point.
>                               shiftedCenterOriginSep = &
>                                  & sum((centerOriginVect(:) - &
>                                  & cellDimsReal(:,p))**2)
599,604c587,590
<                                  ! Check if shifted seperation between the
<                                  !   center and the origin extends past the
<                                  !   negligability limit.  If so, cycle to the
<                                  !   next cell.
<                                  if (shiftedCenterOriginSep > &
<                                        & threeAlphaDist) cycle
---
>                               ! Check if shifted seperation between the center
>                               !   and the origin extends past the negligability
>                               !   limit.  If so, cycle to the next cell.
>                               if (shiftedCenterOriginSep > threeAlphaDist) cycle
606,608c592,594
<                                  ! Get seperation shifted by the lattice point.
<                                  shiftedPotPos(:) = potPosition(:) + &
<                                        & latticeVector2(:) + cellDimsReal(:,p)
---
>                               ! Get the seperation shifted by the lattice point.
>                               shiftedPotPos(:) = potPosition(:) + &
>                                     & latticeVector2(:) + cellDimsReal(:,p)
610,611c596,597
<                                  if (n <= currentNumPotAlphas) then
<                                     call genMatrix (oneAlphaSet,&
---
>                               if (n <= currentNumPotAlphas) then
>                                  call genMatrix (oneAlphaSet,&
617c603,604
<                                        & shiftedAtomPos(:),shiftedPotPos(:),2)
---
>                                        & shiftedAtomPos(:),shiftedPotPos(:),&
>                                        & logWaveFnThresh,test,2)
619,620c606,616
<                                     ! Accumulate results returned for alpha set.
<                                     do q = 1, spin
---
> !                                call gaussian3Center (oneAlphaSet,&
> !                                      & currentlmAlphaIndex (alphaIndex(1),1),&
> !                                      & currentlmAlphaIndex (alphaIndex(2),2),&
> !                                      & currentAlphas(alphaIndex(1),1),&
> !                                      & currentAlphas(alphaIndex(2),2),&
> !                                      & currentPotAlpha,currentPosition(:,1),&
> !                                      & shiftedAtomPos(:),shiftedPotPos(:),&
> !                                      & logWaveFnThresh,test)
> 
>                                  ! Accumulate results returned for alpha set.
>                                  do q = 1, spin
631,632c627,628
<                                     enddo
<                                  else
---
>                                  enddo
>                               else
634c630
<                                     call genMatrix (oneAlphaSet,&
---
>                                  call genMatrix (oneAlphaSet,&
640c636,637
<                                        & shiftedAtomPos(:),shiftedPotPos(:),1)
---
>                                        & shiftedAtomPos(:),shiftedPotPos(:),&
>                                        & logWaveFnThresh,test,1)
642,661d638
<                                     ! Accumulate results returned for alpha set.
<                                     do q = 1, spin
<                                        potAtomOverlap(:currentlmAlphaIndex &
<                                           & (alphaIndex(1),1),&
<                                           & :currentlmAlphaIndex &
<                                           & (alphaIndex(2),2),q) = &
<                                           & potAtomOverlap(:currentlmAlphaIndex&
<                                           & (alphaIndex(1),1),&
<                                           & :currentlmAlphaIndex &
<                                           & (alphaIndex(2),2),q) - &
<                                           & oneAlphaSet(:currentlmAlphaIndex &
<                                           & (alphaIndex(1),1),&
<                                           & :currentlmAlphaIndex &
<                                           & (alphaIndex(2),2)) * zFactor
<                                     enddo
<                                  endif
<                               enddo ! (p numCells)
<                            enddo ! (o multiplicity)
<                         enddo ! (n numCurrentPotAlphas+1)
<                      enddo ! (m numPots (inequivalent))
663,670c640,647
<                      ! Determine the kinetic energy contribution
<                      call genMatrix (oneAlphaSet,&
<                            & currentlmAlphaIndex (alphaIndex(1),1),&
<                            & currentlmAlphaIndex (alphaIndex(2),2),&
<                            & currentAlphas(alphaIndex(1),1),&
<                            & currentAlphas(alphaIndex(2),2),&
<                            & emptyAlpha,currentPosition(:,1),shiftedAtomPos(:),&
<                            & emptyPosition,3)
---
> !                                 call gaussian3CenterInvR (oneAlphaSet,&
> !                                      & currentlmAlphaIndex (alphaIndex(1),1),&
> !                                      & currentlmAlphaIndex (alphaIndex(2),2),&
> !                                      & currentAlphas(alphaIndex(1),1),&
> !                                      & currentAlphas(alphaIndex(2),2),&
> !                                      & currentPotAlpha,currentPosition(:,1),&
> !                                      & shiftedAtomPos(:),shiftedPotPos(:),&
> !                                      & logWaveFnThresh,test)
672,683c649,668
<                      ! Accumulate the contribution from this alpha pair
<                      do m = 1, spin
<                         potAtomOverlap(:currentlmAlphaIndex &
<                               & (alphaIndex(1),1),:currentlmAlphaIndex &
<                               & (alphaIndex(2),2),m) = &
<                               & potAtomOverlap(:currentlmAlphaIndex &
<                               & (alphaIndex(1),1),:currentlmAlphaIndex &
<                               & (alphaIndex(2),2),m) + &
<                               & oneAlphaSet(:currentlmAlphaIndex &
<                               & (alphaIndex(1),1),:currentlmAlphaIndex &
<                               & (alphaIndex(2),2))
<                      enddo
---
>                                  ! Accumulate results returned for alpha set.
>                                  do q = 1, spin
>                                     potAtomOverlap(:currentlmAlphaIndex &
>                                        & (alphaIndex(1),1),&
>                                        & :currentlmAlphaIndex &
>                                        & (alphaIndex(2),2),q) = &
>                                        & potAtomOverlap(:currentlmAlphaIndex &
>                                        & (alphaIndex(1),1),&
>                                        & :currentlmAlphaIndex &
>                                        & (alphaIndex(2),2),q) - &
>                                        & oneAlphaSet(:currentlmAlphaIndex &
>                                        & (alphaIndex(1),1),&
>                                        & :currentlmAlphaIndex &
>                                        & (alphaIndex(2),2)) * zFactor
>                                  enddo
>                               endif
>                            enddo ! (p numCells)
>                         enddo ! (o multiplicity)
>                      enddo ! (n numCurrentPotAlphas+1)
>                   enddo ! (m numPots (inequivalent))
686,687c671,988
<                      ! Compute the atomic overlap for this atom pair.
<                      call genMatrix (oneAlphaSet,&
---
> 
> 
> 
> 
> 
> 
> !                  ! Initiate a loop over each potential site for the nuclear
> !                  !   potentials.
> !                  do m = 1, numPots
> !
> !!                     ! Skip equivalent types
> !!                     if (crystal%potData(i)%equivalence /= 0) cycle
> !
> !                     ! Initialize the current nuclear potential
> !                     call initializePotential (m, potType, potElement, &
> !                           & zFactor, nucAlpha, potPosition,crystal,types)
> !
> !                     ! If the zFactor is sufficiently small we consider the
> !                     !   effect of the overlap to be negligable and we cycle
> !                     !   to the next one.
> !                     if (zFactor < smallThresh) cycle
> !
> !                     ! Determine the maximum distance beyond which the overlap
> !                     !   of the three gaussians is considered negligable.
> !                     threeAlphaDist = logWaveFnThresh * (1-shiftedAtomSiteSep/&
> !                           & alphaDist(alphaIndex(1),alphaIndex(2))) * &
> !                           & (currentAlphas(alphaIndex(1),1) + &
> !                           &  currentAlphas(alphaIndex(2),2) + nucAlpha) / &
> !                           & (currentAlphas(alphaIndex(1),1) + &
> !                           &  currentAlphas(alphaIndex(2),2)) / nucAlpha
> !
> !                     ! Locate the origin for the potential lattice sum.
> !                     call findLatticeVector((overlapCenter(:)-potPosition(:)),&
> !                           & latticeVector2, realSuperLatt%cellDims, &
> !                           & crystal%realVectors, lattFinder)
> !
> !                     ! Find the seperation vector and distance between the
> !                     !   minimum overlap center, and the origin.
> !                     centerOriginVect(:) = overlapCenter(:) - potPosition(:) - &
> !                           & latticeVector2
> !                     centerOriginSep = sum(centerOriginVect(:)**2)
> !
> !                     ! Check if the largest potential is negligable or not.
> !                     if (centerOriginSep > threeAlphaDist) cycle
> !
> !                     ! At this point it must be the case that at least one
> !                     !   contribution will be calculated.
> !
> !                     ! First, find the cut-off radius for the potential lattice
> !                     !   summation by the triangle inequality.
> !                     maxLatticeRadius2 = centerOriginSep +  threeAlphaDist + &
> !                           & 2.0_double * sqrt (centerOriginSep*threeAlphaDist)
> !
> !                     ! Check that this calculation makes sense.
> !                     if (maxLatticeRadius2 > realSuperLatt%cellSizes(numCells))&
> !                           & then
> !                        write (20,*) 'More latt pts needed for atom overlap pair'
> !                        write (20,*) 'maxLatticeRadius2 requested=',&
> !                              & maxLatticeRadius2
> !                        write (20,*) 'max available=',&
> !                              & realSuperLatt%cellSizes(numCells)
> !                        stop
> !                     endif
> !
> !
> !                     ! Begin a loop over lattice points for the nuclear pot.
> !                     do n = 1, numCells
> !
> !                        ! Check if this lattice point extends beyond the range
> !                        !   of negligability
> !                        if (realSuperLatt%cellSizes(n) > maxLatticeRadius2) exit
> !
> !                        ! Get the overlap center shifted by the lattice point.
> !                        shiftedcenterOriginSep = sum((centerOriginVect(:) - &
> !                              & realSuperLatt%cellDims(:,n))**2)
> !
> !                        ! Check if the shifted seperation between the center
> !                        !   and the origin extends beyond the negligability
> !                        !   limit.  If so, cycle to the next cell.
> !                        if (shiftedcenterOriginSep > threeAlphaDist) cycle
> !
> !                        ! Get the seperation shifted by the lattice point.
> !                        shiftedPotPos(:) = potPosition(:) + latticeVector2(:) +&
> !                              & realSuperLatt%cellDims(:,n)
> !
> !
> !                        call gaussian3CenterInvR (oneAlphaSet,&
> !                              & currentlmAlphaIndex (alphaIndex(1),1),&
> !                              & currentlmAlphaIndex (alphaIndex(2),2),&
> !                              & currentAlphas(alphaIndex(1),1),&
> !                              & currentAlphas(alphaIndex(2),2),nucAlpha,&
> !                              & currentPosition(:,1),shiftedAtomPos(:),&
> !                              & shiftedPotPos(:),logWaveFnThresh,test)
> !
> !                        ! Check for inconsistent exponents from gaussian intg.
> !                        if (.not. test) stop 'INCONSISTENT EXPONENT TESTS 1'
> !
> !                        ! Accumulate the results returned for this alpha set.
> !                        potAtomOverlap(:currentlmAlphaIndex &
> !                              & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                              & (alphaIndex(2),2)) = &
> !                              & potAtomOverlap(:currentlmAlphaIndex &
> !                              & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                              & (alphaIndex(2),2)) - &
> !                              & oneAlphaSet(:currentlmAlphaIndex &
> !                              & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                              & (alphaIndex(2),2)) * zFactor
> !
> !                     enddo ! (n numCells)
> !                  enddo ! (m numPots)
> !                  ! Initialize a counter to track which potential alpha we are
> !                  !   currently calculating on.
> !                  potCoeffIndex = 0
> !
> !                  ! Initiate a loop over each potential site for the nuclear
> !                  !   potentials.
> !                  do m = 1, numPots
> !
> !                     ! Skip equivalent types
> !                     if (crystal%potData(m)%equivalence /= 0) cycle
> !
> !                     ! Initialize the parameters for this potential site
> !                     !   related to the type of this site.
> !                     currentPotType = crystal%potData(i)%potTypeAssn
> !                     currentNumPotAlphas = types%potTypes(currentPotType)%&
> !                           & numAlphas
> !
> !                     ! Store the initial potential coefficient index.
> !                     initPotCoeffIndex = potCoeffIndex
> !
> !                     ! Loop over the remaining potential sites that are
> !                     !   equivalent.
> !                     do n = 0, types%potTypes(currentPotType)%multiplicity - 1
> !
> !                        ! Initialize the parameters for this potential site
> !                        !   related to its position.
> !                        potPosition(:) = crystal%potData(m+n)%position(:)
> !
> !                        ! Locate the origin for the potential lattice sum.
> !                        call findLatticeVector((overlapCenter(:) - &
> !                              & potPosition(:)), latticeVector2, &
> !                              & realSuperLatt%cellDims, crystal%realVectors, &
> !                              & lattFinder)
> !
> !                        ! Initialize the starting point for the potential
> !                        !   coefficients for this equivalent atom.
> !                        potCoeffIndex = initPotCoeffIndex
> !
> !                        ! Begin a loop over each alpha for this potential site.
> !                        do o = 1, currentNumPotAlphas
> !
> !                           ! Obtain the current alpha
> !                           currentPotAlpha = types%potTypes(currentPotType)%&
> !                              & alphas(o)
> !
> !                           ! Increment the potential coefficient index
> !                           potCoeffIndex = potCoeffIndex + 1
> !
> !                           ! Obtain the coefficient for this alpha
> !                           currentPotCoeff = potCoeffs(potCoeffIndex)
> !
> !                           ! Determine the maximum distance beyond which the
> !                           !   overlap of the three gaussians is considered
> !                           !   negligable.
> !                           threeAlphaDist = logWaveFnThresh * (1 - &
> !                                 & shiftedAtomSiteSep / &
> !                                 & alphaDist(alphaIndex(1),alphaIndex(2))) * &
> !                                 & (currentAlphas(alphaIndex(1),1) + &
> !                                 &  currentAlphas(alphaIndex(2),2) + &
> !                                 &  currentpotAlpha) / &
> !                                 & (currentAlphas(alphaIndex(1),1) + &
> !                                 &  currentAlphas(alphaIndex(2),2)) / &
> !                                 &  currentPotAlpha
> !
> !                           ! Find the seperation vector and distance between the
> !                           !   minimum overlap center, and the origin.
> !                           centerOriginVect(:) = overlapCenter(:) - &
> !                                 & potPosition(:) - latticeVector2
> !                           centerOriginSep = sum(centerOriginVect(:)**2)
> !
> !                           ! Check if largest potential is negligable or not.
> !                           if (centerOriginSep > threeAlphaDist) cycle
> !
> !                           ! At this point it must be the case that at least one
> !                           !   contribution will be calculated.
> !
> !                           ! First, find the cut-off radius for the potential
> !                           !   lattice summation by the triangle inequality.
> !                           maxLatticeRadius2 = centerOriginSep + &
> !                              & threeAlphaDist + 2.0_double * &
> !                              & sqrt (centerOriginSep * threeAlphaDist)
> !
> !                           ! Check that this calculation makes sense.
> !                           if (maxLatticeRadius2 > &
> !                                 & realSuperLatt%cellSizes(numCells)) then
> !                              write (20,*) 'Need more latt pts for atom OL pair'
> !                              write (20,*) 'maxLatticeRadius2 requested=',&
> !                                    & maxLatticeRadius2
> !                              write (20,*) 'max available=',&
> !                                    & realSuperLatt%cellSizes(numCells)
> !                              stop
> !                           endif
> !
> !
> !                           ! Begin a loop over lattice points for the site pot.
> !                           do p = 1, numCells
> !
> !                              ! Check if this lattice point extends beyond the
> !                              !   range of negligability
> !                              if (realSuperLatt%cellSizes(p) > &
> !                                    & maxLatticeRadius2) exit
> !
> !                              ! Get overlap center shifted by the lattice point.
> !                              shiftedCenterOriginSep = &
> !                                 & sum((centerOriginVect(:) - &
> !                                 & realSuperLatt%cellDims(:,p))**2)
> !
> !                              ! Check if shifted seperation between the center
> !                              !   and the origin extends past the negligability
> !                              !   limit.  If so, cycle to the next cell.
> !                              if (shiftedCenterOriginSep > threeAlphaDist) cycle
> !
> !                              ! Get the seperation shifted by the lattice point.
> !                              shiftedPotPos(:) = potPosition(:) + &
> !                                    & latticeVector2(:) + &
> !                                    & realSuperLatt%cellDims(:,p)
> !
> !
> !                              call gaussian3Center (oneAlphaSet,&
> !                                    & currentlmAlphaIndex (alphaIndex(1),1),&
> !                                    & currentlmAlphaIndex (alphaIndex(2),2),&
> !                                    & currentAlphas(alphaIndex(1),1),&
> !                                    & currentAlphas(alphaIndex(2),2),&
> !                                    & currentPotAlpha,currentPosition(:,1),&
> !                                    & shiftedAtomPos(:),shiftedPotPos(:),&
> !                                    & logWaveFnThresh,test)
> !
> !                              ! Check: inconsistent exponents from gaussian intg
> !                              if (.not. test) stop 'INCONSISTENT EXP TESTS 2'
> !
> !                              ! Accumulate results returned for this alpha set.
> !                              potAtomOverlap(:currentlmAlphaIndex &
> !                                    & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                                    & (alphaIndex(2),2)) = &
> !                                    & potAtomOverlap(:currentlmAlphaIndex &
> !                                    & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                                    & (alphaIndex(2),2)) + &
> !                                    & oneAlphaSet(:currentlmAlphaIndex &
> !                                    & (alphaIndex(1),1),:currentlmAlphaIndex &
> !                                    & (alphaIndex(2),2)) * currentPotCoeff
> !
> !                           enddo ! (p numCells)
> !                        enddo ! (o numCurrentPotAlphas)
> !                     enddo ! (n Multiplicity pot sites)
> !                  enddo ! (m numPots (inequivalent))
> 
> 
> 
>                   ! Determine the kinetic energy contribution
>                   call genMatrix (oneAlphaSet,&
>                         & currentlmAlphaIndex (alphaIndex(1),1),&
>                         & currentlmAlphaIndex (alphaIndex(2),2),&
>                         & currentAlphas(alphaIndex(1),1),&
>                         & currentAlphas(alphaIndex(2),2),&
>                         & emptyAlpha,currentPosition(:,1),shiftedAtomPos(:),&
>                         & emptyPosition,logWaveFnThresh,test,3)
> 
> 
> !                  call gaussian2CenterKE (oneAlphaSet,&
> !                        & currentlmAlphaIndex (alphaIndex(1),1),&
> !                        & currentlmAlphaIndex (alphaIndex(2),2),&
> !                        & currentAlphas(alphaIndex(1),1),&
> !                        & currentAlphas(alphaIndex(2),2),&
> !                        & currentPosition(:,1),shiftedAtomPos(:),&
> !                        & logWaveFnThresh,test)
> 
>                   ! Check for inconsistent exponents from the gaussian integral
> !                  if (test .eq. 0) stop 'INCONSISTENT EXPONENT TESTS 3'
> 
>                   ! Accumulate the contribution from this alpha pair
>                   do m = 1, spin
>                      potAtomOverlap(:currentlmAlphaIndex &
>                            & (alphaIndex(1),1),:currentlmAlphaIndex &
>                            & (alphaIndex(2),2),m) = &
>                            & potAtomOverlap(:currentlmAlphaIndex &
>                            & (alphaIndex(1),1),:currentlmAlphaIndex &
>                            & (alphaIndex(2),2),m) + &
>                            & oneAlphaSet(:currentlmAlphaIndex &
>                            & (alphaIndex(1),1),:currentlmAlphaIndex &
>                            & (alphaIndex(2),2))
>                   enddo
> 
> 
>                   ! Compute the atomic overlap for this atom pair.
>                   call genMatrix (oneAlphaSet,&
>                         & currentlmAlphaIndex (alphaIndex(1),1),&
>                         & currentlmAlphaIndex (alphaIndex(2),2),&
>                         & currentAlphas(alphaIndex(1),1),&
>                         & currentAlphas(alphaIndex(2),2),&
>                         & emptyAlpha,currentPosition(:,1),shiftedAtomPos(:),&
>                         & emptyPosition(:),logWaveFnThresh,test,4)
> 
> 
> !                  call gaussian2CenterOL (oneAlphaSet,&
> !                        & currentlmAlphaIndex (alphaIndex(1),1),&
> !                        & currentlmAlphaIndex (alphaIndex(2),2),&
> !                        & currentAlphas(alphaIndex(1),1),&
> !                        & currentAlphas(alphaIndex(2),2),&
> !                        & currentPosition(:,1),shiftedAtomPos(:),&
> !                        & logWaveFnThresh, test)
> 
>                   ! Check for inconsistent exponents from the gaussian integral
> !                  if (test .eq. 0) stop 'INCONSISTENT EXPONENT TESTS 4'
> 
> 
>                   ! Compute the momentum matrix values if requested.
>                   if (calcMomentum == 1) then
>                      call MOMF (oneAlphaSetMom,&
692,694c993,994
<                            & emptyAlpha,currentPosition(:,1),shiftedAtomPos(:),&
<                            & emptyPosition(:),4)
< !                  endif
---
>                            & currentPosition(:,1),shiftedAtomPos(:),&
>                            & logWaveFnThresh)
696,699c996
< 
<                   ! Compute the momentum matrix values if requested.
< !                  if (doMOME == 1) then
< !                     call MOMF (oneAlphaSetMom,&
---
> !                     call gaussian2CenterMom (oneAlphaSetMom,&
704,705c1001,1003
< !                           & currentPosition(:,1),shiftedAtomPos(:))
< !                  endif
---
> !                           & currentPosition(:,1),shiftedAtomPos(:),&
> !                           & logWaveFnThresh, test)
>                   endif
710,721c1008,1017
< !                  if (doINTG == 1) then
<                      ! Potential overlaps first (if any were found).
<                      do q = 1, spin
<                         do m = 1, currentNumTotalStates(2)
<                            pairXWaveFn2Ham(:currentlmAlphaIndex( &
<                                  & alphaIndex(1),1),alphaIndex(1),m,q) = &
<                                  & pairXWaveFn2Ham(:currentlmAlphaIndex &
<                                  & (alphaIndex(1),1),alphaIndex(1),m,q) + &
<                                  & potAtomOverlap(:currentlmAlphaIndex &
<                                  & (alphaIndex(1),1),currentlmIndex(m,2),q) * &
<                                  & currentBasisFns(alphaIndex(2),m,2)
<                         enddo
---
>                   ! Potential overlaps first (if any were found).
>                   do q = 1, spin
>                      do m = 1, currentNumTotalStates(2)
>                         pairXWaveFn2Ham(:currentlmAlphaIndex(alphaIndex(1),1),&
>                               & alphaIndex(1),m,q) = &
>                               & pairXWaveFn2Ham(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),alphaIndex(1),m,q) + &
>                               & potAtomOverlap(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),currentlmIndex(m,2),q) * &
>                               & currentWaveFns(alphaIndex(2),m,2)
723c1019,1032
<                      ! Atom pair overlaps second.
---
>                   enddo
>                   ! Atom pair overlaps second.
>                   do m = 1, currentNumTotalStates(2)
>                      pairXWaveFn2OL(:currentlmAlphaIndex(alphaIndex(1),1),&
>                            & alphaIndex(1),m) = &
>                            & pairXWaveFn2OL(:currentlmAlphaIndex &
>                            & (alphaIndex(1),1),alphaIndex(1),m) + &
>                            & oneAlphaSet(:currentlmAlphaIndex &
>                            & (alphaIndex(1),1),currentlmIndex(m,2)) * &
>                            & currentWaveFns(alphaIndex(2),m,2)
>                   enddo
> 
>                   ! Momentum matrix last.  (If requested)
>                   if (calcMomentum == 1) then
725,727c1034,1036
<                         pairXWaveFn2OL(:currentlmAlphaIndex(alphaIndex(1),1),&
<                               & alphaIndex(1),m) = &
<                               & pairXWaveFn2OL(:currentlmAlphaIndex &
---
>                         pairXWaveFn2MomX(:currentlmAlphaIndex(alphaIndex(1),&
>                               & 1), alphaIndex(1),m) = &
>                               & pairXWaveFn2MomX(:currentlmAlphaIndex &
729,731c1038,1054
<                               & oneAlphaSet(:currentlmAlphaIndex &
<                               & (alphaIndex(1),1),currentlmIndex(m,2)) * &
<                               & currentBasisFns(alphaIndex(2),m,2)
---
>                               & oneAlphaSetMom(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),currentlmIndex(m,2),1) * &
>                               & currentWaveFns(alphaIndex(2),m,2)
>                         pairXWaveFn2MomY(:currentlmAlphaIndex(alphaIndex(1),&
>                               & 1), alphaIndex(1),m) = &
>                               & pairXWaveFn2MomY(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),alphaIndex(1),m) + &
>                               & oneAlphaSetMom(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),currentlmIndex(m,2),2) * &
>                               & currentWaveFns(alphaIndex(2),m,2)
>                         pairXWaveFn2MomZ(:currentlmAlphaIndex(alphaIndex(1),&
>                               & 1), alphaIndex(1),m) = &
>                               & pairXWaveFn2MomZ(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),alphaIndex(1),m) + &
>                               & oneAlphaSetMom(:currentlmAlphaIndex &
>                               & (alphaIndex(1),1),currentlmIndex(m,2),3) * &
>                               & currentWaveFns(alphaIndex(2),m,2)
733c1056
< !                  endif
---
>                   endif
735,761d1057
<                   ! Momentum matrix last.  (If requested)
< !                  if (doMOME == 1) then
< !                     do m = 1, currentNumTotalStates(2)
< !                        pairXWaveFn2MomX(:currentlmAlphaIndex(alphaIndex(1),&
< !                              & 1), alphaIndex(1),m) = &
< !                              & pairXWaveFn2MomX(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),alphaIndex(1),m) + &
< !                              & oneAlphaSetMom(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),currentlmIndex(m,2),1) * &
< !                              & currentBasisFns(alphaIndex(2),m,2)
< !                        pairXWaveFn2MomY(:currentlmAlphaIndex(alphaIndex(1),&
< !                              & 1), alphaIndex(1),m) = &
< !                              & pairXWaveFn2MomY(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),alphaIndex(1),m) + &
< !                              & oneAlphaSetMom(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),currentlmIndex(m,2),2) * &
< !                              & currentBasisFns(alphaIndex(2),m,2)
< !                        pairXWaveFn2MomZ(:currentlmAlphaIndex(alphaIndex(1),&
< !                              & 1), alphaIndex(1),m) = &
< !                              & pairXWaveFn2MomZ(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),alphaIndex(1),m) + &
< !                              & oneAlphaSetMom(:currentlmAlphaIndex &
< !                              & (alphaIndex(1),1),currentlmIndex(m,2),3) * &
< !                              & currentBasisFns(alphaIndex(2),m,2)
< !                     enddo
< !                  endif
< 
772a1069,1072
> !write (20,*) "pairXWaveFn2OL="
> !write (20,*) pairXWaveFn2OL
> !call flush (20)
> 
775,776c1075,1085
<             !   integral in a complete wavefunction representation.
< !            if (doINTG == 1) then
---
>             !   integral in a complete wavefunction representation.  The
>             !   hamiltonian and overlap are done first to prevent an 'if'
>             !   statement from appearing within the l and m loops.
>             do l = 1, currentNumTotalStates(2)
>                do m = 1, currentNumTotalStates(1)
>                   pairXWaveFn12OL(m,l) = &
>                         & sum(currentWaveFns(:maxAlpha1Used,m,1) * &
>                         & pairXWaveFn2OL(currentlmIndex(m,1),:maxAlpha1Used,l))
>                enddo
>             enddo
>             do q = 1, spin
779,782c1088,1091
<                      pairXWaveFn12OL(m,l) = &
<                            & sum(currentBasisFns(:maxAlpha1Used,m,1) * &
<                            & pairXWaveFn2OL(currentlmIndex(m,1),&
<                            & :maxAlpha1Used,l))
---
>                      pairXWaveFn12Ham(m,l,q) = &
>                            & sum(currentWaveFns(:maxAlpha1Used,m,1) * &
>                            & pairXWaveFn2Ham(currentlmIndex(m,1),&
>                            & :maxAlpha1Used,l,q))
785,792c1094,1111
<                do q = 1, spin
<                   do l = 1, currentNumTotalStates(2)
<                      do m = 1, currentNumTotalStates(1)
<                         pairXWaveFn12Ham(m,l,q) = &
<                               & sum(currentBasisFns(:maxAlpha1Used,m,1) * &
<                               & pairXWaveFn2Ham(currentlmIndex(m,1),&
<                               & :maxAlpha1Used,l,q))
<                      enddo
---
>             enddo
> 
>             ! The momentum is summed against the wave function 1 if needed.
>             if (calcMomentum == 1) then
>                do l = 1, currentNumTotalStates(2)
>                   do m = 1, currentNumTotalStates(1)
>                   pairXWaveFn12MomX(m,l) = &
>                         & sum(currentWaveFns(:maxAlpha1Used,m,1) * &
>                         & pairXWaveFn2MomX(currentlmIndex(m,1), &
>                         & :maxAlpha1Used,l))
>                   pairXWaveFn12MomY(m,l) = &
>                         & sum(currentWaveFns(:maxAlpha1Used,m,1) * &
>                         & pairXWaveFn2MomY(currentlmIndex(m,1), &
>                         & :maxAlpha1Used,l))
>                   pairXWaveFn12MomZ(m,l) = &
>                         & sum(currentWaveFns(:maxAlpha1Used,m,1) * &
>                         & pairXWaveFn2MomZ(currentlmIndex(m,1), &
>                         & :maxAlpha1Used,l))
795c1114
< !            endif
---
>             endif
797,816d1115
<             ! The momentum is summed against the wave function 1 if needed.
< !            if (doMOME == 1) then
< !               do l = 1, currentNumTotalStates(2)
< !                  do m = 1, currentNumTotalStates(1)
< !                  pairXWaveFn12MomX(m,l) = &
< !                        & sum(currentBasisFns(:maxAlpha1Used,m,1) * &
< !                        & pairXWaveFn2MomX(currentlmIndex(m,1), &
< !                        & :maxAlpha1Used,l))
< !                  pairXWaveFn12MomY(m,l) = &
< !                        & sum(currentBasisFns(:maxAlpha1Used,m,1) * &
< !                        & pairXWaveFn2MomY(currentlmIndex(m,1), &
< !                        & :maxAlpha1Used,l))
< !                  pairXWaveFn12MomZ(m,l) = &
< !                        & sum(currentBasisFns(:maxAlpha1Used,m,1) * &
< !                        & pairXWaveFn2MomZ(currentlmIndex(m,1), &
< !                        & :maxAlpha1Used,l))
< !                  enddo
< !               enddo
< !            endif
< 
826,827c1125,1134
< !            if (doINTG == 1) then
<                accumulatedOL(:currentNumTotalStates(1),cumulDataSize + 1:&
---
>             accumulatedOL(:currentNumTotalStates(1),cumulDataSize + 1:&
>                   & cumulDataSize + currentNumTotalStates(2)) = &
>                   & pairXWaveFn12OL(:currentNumTotalStates(1),:&
>                   & currentNumTotalStates(2))
>             accumulatedHam(:currentNumTotalStates(1),cumulDataSize + 1:&
>                   & cumulDataSize + currentNumTotalStates(2),:spin) = &
>                   & pairXWaveFn12Ham(:currentNumTotalStates(1),:&
>                   & currentNumTotalStates(2),:spin)
>             if (calcMomentum == 1) then
>                accumulatedMomX(:currentNumTotalStates(1),cumulDataSize + 1:&
829c1136
<                      & pairXWaveFn12OL(:currentNumTotalStates(1),:&
---
>                      & pairXWaveFn12MomX(:currentNumTotalStates(1),:&
831,849c1138,1146
<                accumulatedHam(:currentNumTotalStates(1),cumulDataSize + 1:&
<                      & cumulDataSize + currentNumTotalStates(2),:spin) = &
<                      & pairXWaveFn12Ham(:currentNumTotalStates(1),:&
<                      & currentNumTotalStates(2),:spin)
< !            endif
< !            if (doMOME == 1) then
< !               accumulatedMomX(:currentNumTotalStates(1),cumulDataSize + 1:&
< !                     & cumulDataSize + currentNumTotalStates(2)) = &
< !                     & pairXWaveFn12MomX(:currentNumTotalStates(1),:&
< !                     & currentNumTotalStates(2))
< !               accumulatedMomY(:currentNumTotalStates(1),cumulDataSize + 1:&
< !                     & cumulDataSize + currentNumTotalStates(2)) = &
< !                     & pairXWaveFn12MomY(:currentNumTotalStates(1),:&
< !                     & currentNumTotalStates(2))
< !               accumulatedMomZ(:currentNumTotalStates(1),cumulDataSize + 1:&
< !                     & cumulDataSize + currentNumTotalStates(2)) = &
< !                     & pairXWaveFn12MomZ(:currentNumTotalStates(1),:&
< !                     & currentNumTotalStates(2))
< !            endif
---
>                accumulatedMomY(:currentNumTotalStates(1),cumulDataSize + 1:&
>                      & cumulDataSize + currentNumTotalStates(2)) = &
>                      & pairXWaveFn12MomY(:currentNumTotalStates(1),:&
>                      & currentNumTotalStates(2))
>                accumulatedMomZ(:currentNumTotalStates(1),cumulDataSize + 1:&
>                      & cumulDataSize + currentNumTotalStates(2)) = &
>                      & pairXWaveFn12MomZ(:currentNumTotalStates(1),:&
>                      & currentNumTotalStates(2))
>             endif
867c1164
<                call saveCurrentAccumulation(doINTG,maxNumStates)
---
>                call saveCurrentAccumulation(calcMomentum,maxNumStates)
895c1192,1193
<          call saveCurrentAccumulation(doINTG,maxNumStates)
---
> 
>          call saveCurrentAccumulation(calcMomentum,maxNumStates)
903c1201
<       call closeAtomHDF (doINTG)
---
>       call closeAtomHDF (calcMomentum)
920c1218
<    deallocate (currentBasisFns)
---
>    deallocate (currentWaveFns)
925a1224,1227
>    deallocate (pairXWaveFn2OL)
>    deallocate (pairXWaveFn2Ham)
>    deallocate (pairXWaveFn12OL)
>    deallocate (pairXWaveFn12Ham)
927,932c1229,1236
< !   if (doINTG == 1) then
<       deallocate (pairXWaveFn2OL)
<       deallocate (pairXWaveFn2Ham)
<       deallocate (pairXWaveFn12OL)
<       deallocate (pairXWaveFn12Ham)
< !   endif
---
>    if (calcMomentum == 1) then
>       deallocate (pairXWaveFn2MomX)
>       deallocate (pairXWaveFn2MomY)
>       deallocate (pairXWaveFn2MomZ)
>       deallocate (pairXWaveFn12MomX)
>       deallocate (pairXWaveFn12MomY)
>       deallocate (pairXWaveFn12MomZ)
>    endif
934,941c1238,1241
< !   if (doMOME == 1) then
< !      deallocate (pairXWaveFn2MomX)
< !      deallocate (pairXWaveFn2MomY)
< !      deallocate (pairXWaveFn2MomZ)
< !      deallocate (pairXWaveFn12MomX)
< !      deallocate (pairXWaveFn12MomY)
< !      deallocate (pairXWaveFn12MomZ)
< !   endif
---
>    ! Log the date and time we end.
>    call date_and_time(date,time)
>    write (20,*)
>    write (20,100) date,time
943,944c1243,1244
<    ! Log the date and time we start.
<    call timeStampEnd(20)
---
>    write (20,*) '*****  End All Integrals and Momentum Matrix  *****'
>    write (20,*) '***************************************************'
946c1246
< end subroutine intgAndOrMom
---
>    100 format ('Date is: ',a8,' Time is: ',a10) ! Date and time output format
947a1248
> end subroutine intgAndMom
950d1250
< subroutine initAtomHDF (i,doINTG)
951a1252,1254
> 
> subroutine initAtomHDF (i,calcMomentum)
> 
953,960c1256,1259
<    use O_Kinds
<    use O_Constants
<    use O_CommandLine
<    use O_Basis
<    use O_Lattice
<    use O_AtomicSites
<    use O_AtomicTypes
<    use O_PSCFIntgHDF5
---
>    use olcao_kinds
>    use constants
> 
>    ! Import the necessary HDF data
961a1261
>    use HDF5IntgDataModule
962a1263,1272
>    ! Import the necessary interfaces
>    use initAtomInterface
>    use findLattVecInterface
> 
>    ! Import the necessary data modules
>    use TypesDataModule
>    use CrystalDataModule
>    use ProbeDataModule
>    use RealSuperLattDataModule
> 
968c1278,1279
<    integer :: doINTG
---
>    integer :: calcMomentum
>    character*30 :: currentName
971d1281
<    character*30 :: currentName
992c1302
<    real (kind=double), allocatable, dimension (:,:,:) :: currentBasisFns
---
>    real (kind=double), allocatable, dimension (:,:,:) :: currentWaveFns
1011c1321
<    allocate (currentBasisFns        (maxNumAtomAlphas,maxNumStates,2))
---
>    allocate (currentWaveFns        (maxNumAtomAlphas,maxNumStates,2))
1018,1019c1328,1329
<    allocate (loopIndices(2,numAtomSites * numCellsReal))
<    allocate (cumulDataSize(numAtomSites * numCellsReal))
---
>    allocate (loopIndices(2,numAtoms * numCellsReal))
>    allocate (cumulDataSize(numAtoms * numCellsReal))
1024c1334
<    call initializeAtomSite(i,1,currentAtomType,currentElements,&
---
>    call initializeAtom(i,1,currentAtomType,currentElements,&
1027c1337
<          & currentPosition,currentAlphas,currentBasisFns)
---
>          & currentPosition,currentAlphas,currentWaveFns)
1045c1355
<    do j = i, numAtomSites
---
>    do j = i, numAtoms
1049c1359
<       call initializeAtomSite(j,2,currentAtomType,currentElements,&
---
>       call initializeAtom(j,2,currentAtomType,currentElements,&
1052c1362
<             & currentPosition,currentAlphas,currentBasisFns)
---
>             & currentPosition,currentAlphas,currentWaveFns)
1060c1370
<             & latticeVector)
---
>             & latticeVector,cellDimsReal,realVectors)
1068c1378
<       currentNegligLimit = logBasisFnThresh * (currentAlphas(1,1) + &
---
>       currentNegligLimit = logWaveFnThresh * (currentAlphas(1,1) + &
1280,1295c1590,1603
< !   if (doINTG == 1) then
<       do j = 1, spin
<          call h5screate_simple_f(2,totalDataDims,fileHamiltonian_dsid(j),hdferr)
<          if (hdferr /= 0) stop 'Failed to create file ham dsid'
<       enddo
<       call h5screate_simple_f (2,totalDataDims,fileOverlap_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to create file overlap dsid'
< !   endif
< !   if (doMOME == 1) then
< !      call h5screate_simple_f (2,totalDataDims,fileMomentumX_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to create file momentum x dsid'
< !      call h5screate_simple_f (2,totalDataDims,fileMomentumY_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to create file momentum y dsid'
< !      call h5screate_simple_f (2,totalDataDims,fileMomentumZ_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to create file momentum z dsid'
< !   endif
---
>    do j = 1, spin
>       call h5screate_simple_f (2,totalDataDims,fileHamiltonian_dsid(j),hdferr)
>       if (hdferr /= 0) stop 'Failed to create file ham dsid'
>    enddo
>    call h5screate_simple_f (2,totalDataDims,fileOverlap_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to create file overlap dsid'
>    if (calcMomentum == 1) then
>       call h5screate_simple_f (2,totalDataDims,fileMomentumX_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to create file momentum x dsid'
>       call h5screate_simple_f (2,totalDataDims,fileMomentumY_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to create file momentum y dsid'
>       call h5screate_simple_f (2,totalDataDims,fileMomentumZ_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to create file momentum z dsid'
>    endif
1310,1319c1618,1619
< !   if (doINTG == 1) then
<       do j = 1, spin
<          write (currentName,*) i,j
<          currentName = trim (currentName)
<          call h5dcreate_f (hamiltonian_gid,currentName,H5T_NATIVE_DOUBLE,&
<                & fileHamiltonian_dsid(j),hamiltonian_did(j),&
<                & hdferr,fileData_plid)
<          if (hdferr /= 0) stop 'Failed to create hamiltonian dataset'
<       enddo
<       write (currentName,*) i
---
>    do j = 1, spin
>       write (currentName,*) i,j
1321,1337c1621,1640
<       call h5dcreate_f (overlap_gid,currentName,H5T_NATIVE_DOUBLE,&
<             & fileOverlap_dsid,overlap_did,hdferr,fileData_plid)
<       if (hdferr /= 0) stop 'Failed to create overlap dataset'
< !   endif
< !   if (doMOME == 1) then
< !      write (currentName,*) i
< !      currentName = trim (currentName)
< !      call h5dcreate_f (momentumX_gid,currentName,H5T_NATIVE_DOUBLE,&
< !            & fileMomentumX_dsid,momentumX_did,hdferr,fileData_plid)
< !      if (hdferr /= 0) stop 'Failed to create momentum x dataset'
< !      call h5dcreate_f (momentumY_gid,currentName,H5T_NATIVE_DOUBLE,&
< !            & fileMomentumY_dsid,momentumY_did,hdferr,fileData_plid)
< !      if (hdferr /= 0) stop 'Failed to create momentum y dataset'
< !      call h5dcreate_f (momentumZ_gid,currentName,H5T_NATIVE_DOUBLE,&
< !            & fileMomentumZ_dsid,momentumZ_did,hdferr,fileData_plid)
< !      if (hdferr /= 0) stop 'Failed to create momentum z dataset'
< !   endif
---
>       call h5dcreate_f (hamiltonian_gid,currentName,H5T_NATIVE_DOUBLE,&
>             & fileHamiltonian_dsid(j),hamiltonian_did(j),hdferr,fileData_plid)
>       if (hdferr /= 0) stop 'Failed to create hamiltonian dataset'
>    enddo
>    write (currentName,*) i
>    currentName = trim (currentName)
>    call h5dcreate_f (overlap_gid,currentName,H5T_NATIVE_DOUBLE,&
>          & fileOverlap_dsid,overlap_did,hdferr,fileData_plid)
>    if (hdferr /= 0) stop 'Failed to create overlap dataset'
>    if (calcMomentum == 1) then
>       call h5dcreate_f (momentumX_gid,currentName,H5T_NATIVE_DOUBLE,&
>             & fileMomentumX_dsid,momentumX_did,hdferr,fileData_plid)
>       if (hdferr /= 0) stop 'Failed to create momentum x dataset'
>       call h5dcreate_f (momentumY_gid,currentName,H5T_NATIVE_DOUBLE,&
>             & fileMomentumY_dsid,momentumY_did,hdferr,fileData_plid)
>       if (hdferr /= 0) stop 'Failed to create momentum y dataset'
>       call h5dcreate_f (momentumZ_gid,currentName,H5T_NATIVE_DOUBLE,&
>             & fileMomentumZ_dsid,momentumZ_did,hdferr,fileData_plid)
>       if (hdferr /= 0) stop 'Failed to create momentum z dataset'
>    endif
1344,1353c1647,1650
<    ! It is only necessary to record the index tracking information when doing
<    !   the overlap and hamiltonian integrals.  When doing *only* the momentum
<    !   integrals it is *assumed* (certain) that the index information was
<    !   already computed for the overlap and hamiltonian (because they should
<    !   have been done first).
< !   if (doINTG == 1) then
<       ! Make the dataspace for the file to track the index number of the atom2
<       !   loop and the lattice loop for reading in the data later.
<       call h5screate_simple_f (2,totalLoopIndexDims,fileLoopIndices_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to create file loop indices dsid'
---
>    ! Make the dataspace for the file to track the index number of the atom2
>    !   loop and the lattice loop for reading in the data later.
>    call h5screate_simple_f (2,totalLoopIndexDims,fileLoopIndices_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to create file loop indices dsid'
1355,1364c1652,1661
<       ! Make the property list for the index tracking dataset for this i atom.
<       call h5pcreate_f       (H5P_DATASET_CREATE_F,fileLoopIndices_plid,hdferr)
<       if (hdferr /= 0) stop 'Failed to create file loop indices plid'
<       call h5pset_layout_f   (fileLoopIndices_plid,H5D_CHUNKED_F,hdferr)
<       if (hdferr /= 0) stop 'Failed to set file loop indices layout'
<       call h5pset_chunk_f    (fileLoopIndices_plid,2,loopIndexChunkSize,hdferr)
<       if (hdferr /= 0) stop 'Failed to set file loop indices chunk size'
< !      call h5pset_shuffle_f (fileLoopIndices_plid,hdferr)
<       call h5pset_deflate_f  (fileLoopIndices_plid,1,hdferr)
<       if (hdferr /= 0) stop 'Failed to set file loop indices for deflation'
---
>    ! Make the property list for the index tracking dataset for this i atom.
>    call h5pcreate_f       (H5P_DATASET_CREATE_F,fileLoopIndices_plid,hdferr)
>    if (hdferr /= 0) stop 'Failed to create file loop indices plid'
>    call h5pset_layout_f   (fileLoopIndices_plid,H5D_CHUNKED_F,hdferr)
>    if (hdferr /= 0) stop 'Failed to set file loop indices layout'
>    call h5pset_chunk_f    (fileLoopIndices_plid,2,loopIndexChunkSize,hdferr)
>    if (hdferr /= 0) stop 'Failed to set file loop indices chunk size'
> !   call h5pset_shuffle_f (fileLoopIndices_plid,hdferr)
>    call h5pset_deflate_f  (fileLoopIndices_plid,1,hdferr)
>    if (hdferr /= 0) stop 'Failed to set file loop indices for deflation'
1367,1371c1664,1668
<       ! Make a dataset to track the index numbers of the atom2 loop and the
<       !   lattice loop for reading in the data later.
<       call h5dcreate_f (loopIndices_gid,currentName,H5T_NATIVE_INTEGER,&
<             & fileLoopIndices_dsid,loopIndices_did,hdferr,fileLoopIndices_plid)
<       if (hdferr /= 0) stop 'Failed to create loop indices data set'
---
>    ! Make a dataset to track the index numbers of the atom2 loop and the
>    !   lattice loop for reading in the data later.
>    call h5dcreate_f (intg_fid,currentName,H5T_NATIVE_INTEGER,&
>          & fileLoopIndices_dsid,loopIndices_did,hdferr,fileLoopIndices_plid)
>    if (hdferr /= 0) stop 'Failed to create loop indices data set'
1373,1376c1670,1672
<       ! Make the dataspace for the memory reference of the loop index matrix.
<       call h5screate_simple_f (2,loopIndexChunkSize,loopIndexChunk_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to create loop index chunk size dsid'
< !   endif
---
>    ! Make the dataspace for the memory reference of the loop index matrix.
>    call h5screate_simple_f (2,loopIndexChunkSize,loopIndexChunk_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to create loop index chunk size dsid'
1386c1682
<    deallocate (currentBasisFns)
---
>    deallocate (currentWaveFns)
1393c1689
<    ! Allocate current loop index space and initialize it.
---
>    ! Allocate current loop index space
1396d1691
<    currentLoopIndices(:,:) = 0
1398,1402c1693,1695
<    ! Allocate accumulation space for the overlap and hamiltonian if required.
< !   if (doINTG == 1) then
<       allocate (accumulatedOL  (int(dataChunkSize(1)),int(dataChunkSize(2))))
<       allocate (accumulatedHam (int(dataChunkSize(1)),&
<             & int(dataChunkSize(2)),spin))
---
>    ! Allocate accumulation space
>    allocate (accumulatedOL  (int(dataChunkSize(1)),int(dataChunkSize(2))))
>    allocate (accumulatedHam (int(dataChunkSize(1)),int(dataChunkSize(2)),spin))
1404,1407c1697,1700
<       ! Initialize matrices.
<       accumulatedOL(:,:)      = 0.0_double
<       accumulatedHam(:,:,:)   = 0.0_double
< !   endif
---
>    ! Initialize matrices.
>    accumulatedOL(:,:)      = 0.0_double
>    accumulatedHam(:,:,:)   = 0.0_double
>    currentLoopIndices(:,:) = 0
1410,1421c1703
< !   if (doMOME == 1) then
< !
< !      ! Allocate accumulation space
< !      allocate (accumulatedMomX (int(dataChunkSize(1)),int(dataChunkSize(2))))
< !      allocate (accumulatedMomY (int(dataChunkSize(1)),int(dataChunkSize(2))))
< !      allocate (accumulatedMomZ (int(dataChunkSize(1)),int(dataChunkSize(2))))
< !
< !      ! Initialize matrices
< !      accumulatedMomX(:,:)    = 0.0_double
< !      accumulatedMomY(:,:)    = 0.0_double
< !      accumulatedMomZ(:,:)    = 0.0_double
< !   endif
---
>    if (calcMomentum == 1) then
1422a1705,1715
>       ! Allocate accumulation space
>       allocate (accumulatedMomX (int(dataChunkSize(1)),int(dataChunkSize(2))))
>       allocate (accumulatedMomY (int(dataChunkSize(1)),int(dataChunkSize(2))))
>       allocate (accumulatedMomZ (int(dataChunkSize(1)),int(dataChunkSize(2))))
> 
>       ! Initialize matrices
>       accumulatedMomX(:,:)    = 0.0_double
>       accumulatedMomY(:,:)    = 0.0_double
>       accumulatedMomZ(:,:)    = 0.0_double
>    endif
> 
1426d1718
< subroutine closeAtomHDF (doINTG)
1427a1720,1722
> 
> subroutine closeAtomHDF (calcMomentum)
> 
1429,1431c1724,1727
<    use O_Kinds
<    use O_CommandLine
<    use O_PSCFIntgHDF5
---
>    use olcao_kinds
>    use ProbeDataModule
> 
>    ! Import the necessary HDF data
1432a1729
>    use HDF5IntgDataModule
1437,1438c1734,1735
<    ! Define the dummy variables passed to this subroutine
<    integer :: doINTG
---
>    ! Define the data structure variables passed to this subroutine
>    integer :: calcMomentum
1445,1460c1742,1757
< !   if (doINTG == 1) then
<       do i = 1, spin
<          call h5sclose_f (fileHamiltonian_dsid(i),hdferr)
<          if (hdferr /= 0) stop 'Failed to close file hamiltonian dsid'
<       enddo
<       call h5sclose_f (fileOverlap_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to close file overlap dsid'
< !   endif
< !   if (doMOME == 1) then
< !      call h5sclose_f (fileMomentumX_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close file momentum x dsid'
< !      call h5sclose_f (fileMomentumY_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close file momentum y dsid'
< !      call h5sclose_f (fileMomentumZ_dsid,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close file momentum z dsid'
< !   endif
---
>    do i = 1, spin
>       call h5sclose_f (fileHamiltonian_dsid(i),hdferr)
>       if (hdferr /= 0) stop 'Failed to close file hamiltonian dsid'
>    enddo
>    call h5sclose_f (fileLoopIndices_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to close file loop indices dsid'
>    call h5sclose_f (fileOverlap_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to close file overlap dsid'
>    if (calcMomentum == 1) then
>       call h5sclose_f (fileMomentumX_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to close file momentum x dsid'
>       call h5sclose_f (fileMomentumY_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to close file momentum y dsid'
>       call h5sclose_f (fileMomentumZ_dsid,hdferr)
>       if (hdferr /= 0) stop 'Failed to close file momentum z dsid'
>    endif
1462,1467d1758
<    ! Close the data space for the loop indices.
< !   if (doINTG == 1) then
<       call h5sclose_f (fileLoopIndices_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to close file loop indices dsid'
< !   endif
< 
1469,1472c1760,1761
< !   if (doINTG == 1) then
<       call h5sclose_f (loopIndexChunk_dsid,hdferr)
<       if (hdferr /= 0) stop 'Failed to close loop index chunk dsid'
< !   endif
---
>    call h5sclose_f (loopIndexChunk_dsid,hdferr)
>    if (hdferr /= 0) stop 'Failed to close loop index chunk dsid'
1477,1480c1766,1767
< !   if (doINTG == 1) then
<       call h5pclose_f (fileLoopIndices_plid,hdferr)
<       if (hdferr /= 0) stop 'Failed to close file loop indices plid'
< !   endif
---
>    call h5pclose_f (fileLoopIndices_plid,hdferr)
>    if (hdferr /= 0) stop 'Failed to close file loop indices plid'
1484,1500c1771,1787
<    ! Close the datasets used for the file output.
< !   if (doINTG == 1) then
<       do i = 1, spin
<          call h5dclose_f (hamiltonian_did(i),hdferr)
<          if (hdferr /= 0) stop 'Failed to close hamiltonian did'
<       enddo
<       call h5dclose_f (overlap_did,hdferr)
<       if (hdferr /= 0) stop 'Failed to close overlap did'
< !   endif
< !   if (doMOME == 1) then
< !      call h5dclose_f (momentumX_did,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close momentum x did'
< !      call h5dclose_f (momentumY_did,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close momentum y did'
< !      call h5dclose_f (momentumZ_did,hdferr)
< !      if (hdferr /= 0) stop 'Failed to close momentum z did'
< !   endif
---
>    ! Lastly, we close the datasets used for the file output.
>    do i = 1, spin
>       call h5dclose_f (hamiltonian_did(i),hdferr)
>       if (hdferr /= 0) stop 'Failed to close hamiltonian did'
>    enddo
>    call h5dclose_f (loopIndices_did,hdferr)
>    if (hdferr /= 0) stop 'Failed to close loop indices did'
>    call h5dclose_f (overlap_did,hdferr)
>    if (hdferr /= 0) stop 'Failed to close overlap did'
>    if (calcMomentum == 1) then
>       call h5dclose_f (momentumX_did,hdferr)
>       if (hdferr /= 0) stop 'Failed to close momentum x did'
>       call h5dclose_f (momentumY_did,hdferr)
>       if (hdferr /= 0) stop 'Failed to close momentum y did'
>       call h5dclose_f (momentumZ_did,hdferr)
>       if (hdferr /= 0) stop 'Failed to close momentum z did'
>    endif
1502,1508c1789
<    ! Close the dataset for the loop indices.
< !   if (doINTG == 1) then
<       call h5dclose_f (loopIndices_did,hdferr)
<       if (hdferr /= 0) stop 'Failed to close loop indices did'
< !   endif
< 
<    ! Deallocate loop indices.
---
>    ! Deallocate accumulation matrices
1509a1791,1797
>    deallocate (accumulatedOL)
>    deallocate (accumulatedHam)
>    if (calcMomentum == 1) then
>       deallocate (accumulatedMomX)
>       deallocate (accumulatedMomY)
>       deallocate (accumulatedMomZ)
>    endif
1511,1521d1798
<    ! Deallocate accumulation matrices.
< !   if (doINTG == 1) then
<       deallocate (accumulatedOL)
<       deallocate (accumulatedHam)
< !   endif
< !   if (doMOME == 1) then
< !      deallocate (accumulatedMomX)
< !      deallocate (accumulatedMomY)
< !      deallocate (accumulatedMomZ)
< !   endif
< 
1527c1804
< subroutine saveCurrentAccumulation(doINTG,maxNumStates)
---
> subroutine saveCurrentAccumulation(calcMomentum,maxNumStates)
1530,1532c1807,1810
<    use O_Kinds
<    use O_CommandLine
<    use O_PSCFIntgHDF5
---
>    use olcao_kinds
>    use ProbeDataModule
> 
>    ! Import the necessary HDF data
1533a1812
>    use HDF5IntgDataModule
1539c1818
<    integer :: doINTG
---
>    integer :: calcMomentum
1546,1572c1825,1827
<    ! Record loop indices in the doINTG case only.  For the doMOME *only* case,
<    !   this *should* already be done and saved in the HDF5 file.
< !   if (doINTG == 1) then
<       ! Choose the hyperslab to write to in the loop indices dataset.
<       call h5sselect_hyperslab_f (fileLoopIndices_dsid,H5S_SELECT_SET_F,&
<             & currentIndexStart,loopIndexChunkSize,hdferr)
<       if (hdferr /= 0) stop 'Failed to select hyperslab for file loop indices'
< 
<       ! Now, record the data.
<       call h5dwrite_f (loopIndices_did,H5T_NATIVE_INTEGER,&
<             & currentLoopIndices(:,:),loopIndexChunkSize,hdferr,&
<             & loopIndexChunk_dsid,fileLoopIndices_dsid)
<       if (hdferr /= 0) stop 'Failed to write loop indices did'
< !   endif
<    
< 
<    ! Perform the extention and recording process for the overlap and
<    !   hamiltonian if necessary.
< !   if (doINTG == 1) then
< 
<       ! Choose the hyperslab to write to in overlap and hamiltonian datasets.
<       do i = 1, spin
<          call h5sselect_hyperslab_f (fileHamiltonian_dsid(i),H5S_SELECT_SET_F,&
<                & currentStart,dataChunkSize,hdferr)
<          if (hdferr /= 0) stop 'Failed to select hyperslab for file hamiltonian'
<       enddo
<       call h5sselect_hyperslab_f (fileOverlap_dsid,H5S_SELECT_SET_F,&
---
>    ! Choose the hyperslab to write to in the file dataset.
>    do i = 1, spin
>       call h5sselect_hyperslab_f (fileHamiltonian_dsid(i),H5S_SELECT_SET_F,&
1574c1829,1836
<       if (hdferr /= 0) stop 'Failed to select hyperslab for file overlap'
---
>       if (hdferr /= 0) stop 'Failed to select hyperslab for file hamiltonian'
>    enddo
>    call h5sselect_hyperslab_f (fileOverlap_dsid,H5S_SELECT_SET_F,&
>          & currentStart,dataChunkSize,hdferr)
>    if (hdferr /= 0) stop 'Failed to select hyperslab for file overlap'
>    call h5sselect_hyperslab_f (fileLoopIndices_dsid,H5S_SELECT_SET_F,&
>          & currentIndexStart,loopIndexChunkSize,hdferr)
>    if (hdferr /= 0) stop 'Failed to select hyperslab for file loop indices'
1576,1586c1838,1847
<       ! Now record the data.
<       do i = 1, spin
<          call h5dwrite_f (hamiltonian_did(i),H5T_NATIVE_DOUBLE,&
<                & accumulatedHam(:,:,i),dataChunkSize,hdferr,dataChunk_dsid,&
<                & fileHamiltonian_dsid(i))
<          if (hdferr /= 0) stop 'Failed to write hamiltonian did'
<       enddo
<       call h5dwrite_f (overlap_did,H5T_NATIVE_DOUBLE,accumulatedOL(:,:),&
<             & dataChunkSize,hdferr,dataChunk_dsid,fileOverlap_dsid)
<       if (hdferr /= 0) stop 'Failed to write overlap did'
< !   endif
---
>    ! Now record the data.
>    do i = 1, spin
>       call h5dwrite_f (hamiltonian_did(i),H5T_NATIVE_DOUBLE,&
>             & accumulatedHam(:,:,i),dataChunkSize,hdferr,dataChunk_dsid,&
>             & fileHamiltonian_dsid(i))
>       if (hdferr /= 0) stop 'Failed to write hamiltonian did'
>    enddo
>    call h5dwrite_f (overlap_did,H5T_NATIVE_DOUBLE,accumulatedOL(:,:),&
>          & dataChunkSize,hdferr,dataChunk_dsid,fileOverlap_dsid)
>    if (hdferr /= 0) stop 'Failed to write overlap did'
1587a1849,1851
>    call h5dwrite_f (loopIndices_did,H5T_NATIVE_INTEGER,currentLoopIndices(:,:),&
>          & loopIndexChunkSize,hdferr,loopIndexChunk_dsid,fileLoopIndices_dsid)
>    if (hdferr /= 0) stop 'Failed to write loop indices did'
1591,1614c1855
< !   if (doMOME == 1) then
< !
< !      ! Choose the hyperslab to write to in the file dataset.
< !      call h5sselect_hyperslab_f (fileMomentumX_dsid,&
< !            & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
< !      if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum x'
< !      call h5sselect_hyperslab_f (fileMomentumY_dsid,&
< !            & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
< !      if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum y'
< !      call h5sselect_hyperslab_f (fileMomentumZ_dsid,&
< !            & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
< !      if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum z'
< !
< !      ! Now record the data.
< !      call h5dwrite_f (momentumX_did,H5T_NATIVE_DOUBLE,accumulatedMomX(:,:),&
< !            & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumX_dsid)
< !      if (hdferr /= 0) stop 'Failed to write momentum x data'
< !      call h5dwrite_f (momentumY_did,H5T_NATIVE_DOUBLE,accumulatedMomY(:,:),&
< !            & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumY_dsid)
< !      if (hdferr /= 0) stop 'Failed to write momentum y data'
< !      call h5dwrite_f (momentumZ_did,H5T_NATIVE_DOUBLE,accumulatedMomZ(:,:),&
< !            & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumZ_dsid)
< !      if (hdferr /= 0) stop 'Failed to write momentum z data'
< !   endif
---
>    if (calcMomentum == 1) then
1615a1857,1879
>       ! Choose the hyperslab to write to in the file dataset.
>       call h5sselect_hyperslab_f (fileMomentumX_dsid,&
>             & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
>       if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum x'
>       call h5sselect_hyperslab_f (fileMomentumY_dsid,&
>             & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
>       if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum y'
>       call h5sselect_hyperslab_f (fileMomentumZ_dsid,&
>             & H5S_SELECT_SET_F,currentStart,dataChunkSize,hdferr)
>       if (hdferr /= 0) stop 'Failed to select hyperslab for file momentum z'
> 
>       ! Now record the data.
>       call h5dwrite_f (momentumX_did,H5T_NATIVE_DOUBLE,accumulatedMomX(:,:),&
>             & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumX_dsid)
>       if (hdferr /= 0) stop 'Failed to write momentum x data'
>       call h5dwrite_f (momentumY_did,H5T_NATIVE_DOUBLE,accumulatedMomY(:,:),&
>             & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumY_dsid)
>       if (hdferr /= 0) stop 'Failed to write momentum y data'
>       call h5dwrite_f (momentumZ_did,H5T_NATIVE_DOUBLE,accumulatedMomZ(:,:),&
>             & dataChunkSize,hdferr,dataChunk_dsid,fileMomentumZ_dsid)
>       if (hdferr /= 0) stop 'Failed to write momentum z data'
>    endif
> 
1627,1630c1891,1892
< !   if (doINTG == 1) then
<       accumulatedOL(:,:)    = 0.0_double
<       accumulatedHam(:,:,:) = 0.0_double
< !   endif
---
>    accumulatedOL(:,:)    = 0.0_double
>    accumulatedHam(:,:,:) = 0.0_double
1633,1639c1895,1899
< !   if (doMOME == 1) then
< !      ! Clear the accumulation data.
< !      accumulatedMomX(:,:) = 0.0_double
< !      accumulatedMomY(:,:) = 0.0_double
< !      accumulatedMomZ(:,:) = 0.0_double
< !   endif
< end subroutine saveCurrentAccumulation
---
>    if (calcMomentum == 1) then
>       ! Clear the accumulation data.
>       accumulatedMomX(:,:) = 0.0_double
>       accumulatedMomY(:,:) = 0.0_double
>       accumulatedMomZ(:,:) = 0.0_double
1641,1738d1900
< 
< #ifndef GAMMA
< subroutine getIntgResults (valeVale,coreValeOL,&
<       & currentKPoint,runCode,valeValeBand_did,valeValeBand_dims,&
<       & noSaveValeVale,spinDirection)
< #else
< subroutine getIntgResults (valeValeGamma,coreValeOLGamma,&
<       & currentKPoint,runCode,valeValeBand_did,valeValeBand_dims,&
<       & noSaveValeVale,spinDirection)
< #endif
< 
<    ! Import the necessary modules
<    use O_Kinds
<    use O_Constants
< 
<    ! Import the necessary HDF5 modules
<    use HDF5
<    use O_PSCFIntgHDF5
< 
<    ! Import the necessary data modules
<    use O_AtomicSites
<    use O_AtomicTypes
<    use O_Lattice
<    use O_KPoints
<    use O_Orthogonalization
<    use O_IntgSaving
< 
< 
<    ! Make sure that there are not accidental variable declarations.
<    implicit none
< 
<    ! Define the variables passed to this subroutine.
< #ifndef GAMMA
<    complex (kind=double), dimension (:,:,:) :: valeVale
<    complex (kind=double), dimension (:,:,:) :: coreValeOL
< #else
<    real (kind=double), dimension (:,:) :: valeValeGamma
<    real (kind=double), dimension (:,:) :: coreValeOLGamma
< #endif
<    integer :: currentKPoint
<    integer :: runCode
<    integer (hid_t) :: valeValeBand_did
<    integer (hsize_t), dimension (2) :: valeValeBand_dims
<    integer :: noSaveValeVale
<    integer :: spinDirection
< 
<    ! Define local variables for logging and loop control
<    integer :: i,j,k,l,m ! Loop index variables
<    integer :: hdferr
< 
<    ! Define local variables for tracking chunks, indices, etc.
<    character*30 :: currentName
<    integer :: numChunks
<    integer(hsize_t) :: numPoints
<    integer :: atom2Index
<    integer :: accumInitPos
< 
<    ! Atom specific variables that change with each atom pair loop iteration.
<    integer, dimension (2) :: currentNumTotalStates
< 
<    ! Variables and data structures that change or are accumulated with each
<    !   iteration of the lattice loop.
< #ifndef GAMMA
<    complex (kind=double), allocatable, dimension (:,:,:) :: currentPair
< #else
<    real (kind=double), allocatable, dimension (:,:)      :: currentPairGamma
< #endif
<    real (kind=double), allocatable, dimension (:,:)      :: accumulatedIntg
<    integer,            allocatable, dimension (:,:)      :: loopIndices
< 
<    ! Variables and data structures that are used to calculate the overlap
<    !   valeVale matrix.
<    integer :: currIndex
< #ifndef GAMMA
<    complex (kind=double), allocatable, dimension (:,:,:) :: coreCore
<    complex (kind=double), allocatable, dimension (:,:,:) :: coreVale
<    complex (kind=double), allocatable, dimension (:,:)   :: valeCore
< #else
<    real (kind=double), allocatable, dimension (:,:)   :: coreCoreGamma
<    real (kind=double), allocatable, dimension (:,:)   :: coreValeGamma
<    real (kind=double), allocatable, dimension (:,:)   :: valeCoreGamma
< #endif
<    real (kind=double), allocatable, dimension (:,:)   :: packedValeVale
< 
<    ! Local position and direction vectors and radii
<    real (kind=double), dimension (dim3) :: latticeVector ! Vector to lattice
<          ! point closest to the difference between the unit cell positions for
<          ! atom 1 and atom 2.
< 
<    ! Initialize the HDF interface for the components needed here.
<    call initReadIntgHDF5 (runCode)
< 
<    ! Allocate space for locally defined allocatable arrays.
< #ifndef GAMMA
<    allocate (currentPair(maxNumStates,maxNumStates,1)) ! Need 1KP at a time.
<    allocate (coreCore(coreDim,coreDim,1)) ! Need 1 KPoint at a time only.
<    if (runCode /= 1) then
<       allocate (coreVale(coreDim,valeDim,1)) ! Need 1 KPoint at a time only.
1740,2297c1902
< # else
<    allocate (currentPairGamma(maxNumStates,maxNumStates))
<    allocate (coreCoreGamma(coreDim,coreDim))
<    if (runCode /= 1) then
<       allocate (coreValeGamma(coreDim,valeDim))
<    endif
< #endif
< 
< 
<    ! Initialize key matrices
< #ifndef GAMMA
<    coreCore(:,:,1) = 0.0_double
<    valeVale(:,:,1) = 0.0_double
<    if (runCode == 1) then
<       coreValeOL(:,:,1) = 0.0_double
<    else
<       coreVale(:,:,1) = 0.0_double
<    endif
< #else
<    coreCoreGamma(:,:) = 0.0_double
<    valeValeGamma(:,:) = 0.0_double
<    if (runCode == 1) then
<       coreValeOLGamma(:,:) = 0.0_double
<    else
<       coreValeGamma(:,:) = 0.0_double
<    endif
< #endif
< 
< 
<    ! For each atom read in the requested results of the atom2-lattice loop
<    !   matrices from the intg calculation.
<    do i = 1, numAtomSites
< 
<       ! Initialize the current atom2 index number and the number of total
<       !   states for this atom pair.
<       atom2Index = i
<       currentNumTotalStates(1) = atomTypes(atomSites(i)%atomTypeAssn)%&
<             & numCoreStates + atomTypes(atomSites(i)%atomTypeAssn)%numValeStates
<       currentNumTotalStates(2) = currentNumTotalStates(1)
< 
<       ! Reset the currentPair
< #ifndef GAMMA
<       currentPair    (:,:,:) = 0.0_double
< #else
<       currentPairGamma (:,:) = 0.0_double
< #endif
< 
< 
<       ! Find the lattice point closest to the difference between the two
<       !   atom sites.
<       call findLatticeVector((atomSites(i)%cartPos(:)-&
<             & atomSites(atom2Index)%cartPos(:)),latticeVector)
< 
<       ! Obtain the name for the datasets for this atom.
<       if (runCode == 2) then
<          write (currentName,*) i,spinDirection
<          currentName = trim (currentName)
< 
<          ! Open the integral dataset for this atom.
<          call h5dopen_f (intg_gid,currentName,intg_did,hdferr)
<          if (hdferr /= 0) stop 'Can not open integral dataset'
< 
<          ! The loopIndex information does not depend on spin direction.
<          write (currentName,*) i
<          currentName = trim (currentName)
< 
<          ! Open the loopIndex dataset for this atom.
<          call h5dopen_f (loopIndices_gid,currentName,loopIndices_did,hdferr)
<          if (hdferr /= 0) stop 'Can not open loop index dataset'
<       else
<          write (currentName,*) i
<          currentName = trim (currentName)
< 
<          ! Open the integral dataset for this atom.
<          call h5dopen_f (intg_gid,currentName,intg_did,hdferr)
<          if (hdferr /= 0) stop 'Can not open integral dataset'
< 
<          ! Open the loopIndex dataset for this atom.
<          call h5dopen_f (loopIndices_gid,currentName,loopIndices_did,hdferr)
<          if (hdferr /= 0) stop 'Can not open loop index dataset'
<       endif
< 
<       ! Determine the number of chunks that make up this dataset.
< 
<       ! Create the dataspace that will describe the overlap file to be read.
<       !   The dataspace covers all the data on the file.  The exact data to
<       !   read will be selected in each j-loop iteration via hyperslab.
<       call h5dget_space_f (intg_did,fileIntg_dsid,hdferr)
<       if (hdferr /= 0) stop 'Can not get space'
<       call h5dget_create_plist_f (intg_did,fileIntg_plid,hdferr)
<       if (hdferr /= 0) stop 'Can not get create plist'
<       call h5pget_chunk_f (fileIntg_plid,2,chunkDims,hdferr)
<       if (hdferr == -1) stop 'Failed to get chunk size'
<       call h5sget_simple_extent_npoints_f (fileIntg_dsid,numPoints,hdferr)
<       if (hdferr == -1) stop 'Failed to get number of points'
<       numPoints = numPoints / currentNumTotalStates(1)
<       numChunks = numPoints / chunkDims(2)
<       if (mod(numPoints,chunkDims(2)) .ne. 0) then
<          numChunks = numChunks + 1
<       endif
< 
<       ! Create the dataspace that will describe the loopIndices file to be
<       !   read.  This dataspace covers all the loop index data on the file.
<       !   The exact loop indices to read will be chosen in the j-loop.
<       call h5dget_space_f (loopIndices_did,fileLoopIndices_dsid,hdferr)
<       if (hdferr /= 0) stop 'Can not get loop index space'
<       call h5dget_create_plist_f (loopIndices_did,fileLoopIndices_plid,hdferr)
<       if (hdferr /= 0) stop 'Can not get loop index create plist'
<       call h5pget_chunk_f (fileLoopIndices_plid,2,loopIndexDims,hdferr)
<       if (hdferr == -1) stop 'Failed to get loop index chunk size'
<       call h5sget_simple_extent_npoints_f (fileLoopIndices_dsid,numPoints,&
<             & hdferr)
<       if (hdferr == -1) stop 'Failed to get loop index number of points'
<       numPoints = numPoints / 2
< 
<       ! Create the dataspace that will describe the intg data in memory.
<       call h5screate_simple_f (2,chunkDims,dataChunk_dsid,hdferr)
<       if (hdferr == -1) stop 'Failed to create dataspace'
< 
<       ! Create the dataspace that will describe the index data in memory.
<       call h5screate_simple_f (2,loopIndexDims,loopIndices_dsid,hdferr)
<       if (hdferr == -1) stop 'Failed to create loop index dataspace'
< 
< 
<       ! Allocate space in memory to read the data and indices.
<       allocate (accumulatedIntg (int(chunkDims(1)),int(chunkDims(2))))
<       allocate (loopIndices (int(loopIndexDims(1)),int(loopIndexDims(2))))
< 
<       ! Initialize the starting locations to read from the file.
<       currentStart(1)      = 0
<       currentStart(2)      = 0
<       currentIndexStart(1) = 0
<       currentIndexStart(2) = 0
< 
< 
<       ! Make a loop to repeatedly read a chunk of data from the datasets for
<       !   this atom.  Read both the data and the loop indices.
<       do j = 1, numChunks
< 
<          ! Choose the hyperslabs to read for this iteration.
<          call h5sselect_hyperslab_f (fileIntg_dsid,H5S_SELECT_SET_F,&
<                & currentStart,chunkDims,hdferr)
<          if (hdferr == -1) stop 'Failed to select hyperslab'
<          call h5sselect_hyperslab_f (fileLoopIndices_dsid,H5S_SELECT_SET_F,&
<                & currentIndexStart,loopIndexDims,hdferr)
<          if (hdferr == -1) stop 'Failed to select loop index hyperslab'
< 
<          ! Now read the data
< 
<          call h5dread_f (loopIndices_did,H5T_NATIVE_INTEGER,loopIndices,&
<                & loopIndexDims,hdferr,loopIndices_dsid,fileLoopIndices_dsid)
<          if (hdferr == -1) stop 'Failed to read loop indices'
<          call h5dread_f (intg_did,H5T_NATIVE_DOUBLE,accumulatedIntg,&
<                & chunkDims,hdferr,dataChunk_dsid,fileIntg_dsid)
<          if (hdferr == -1) stop 'Failed to read integral data'
< 
<          ! If we are not at the last iteration of the j-loop then we increment
<          !   the starting point to the next chunk.
<          if (j .ne. numChunks) then
<             currentStart(2) = currentStart(2) + chunkDims(2)
<             currentIndexStart(2) = currentIndexStart(2) + loopIndexDims(2)
<          endif
< 
<          ! Initialize the position within the chunk that will be the initial
<          !   point to begin operating on the accumulated data.
<          accumInitPos = 0
< 
<          ! Now that we have read in the data we start to compute on it.
<          do k = 1, numPoints
< 
<             ! Check if we reached the end of the data within a given chunk.
<             if (loopIndices(1,k) == 0) then
< 
<                ! Exit the loop over sub-chunks of the current chunk.
<                exit
<             endif
< 
<             ! Check if we are at the next atom from the atom2 loop.
<             if (loopIndices(1,k) .ne. atom2Index) then
< 
<                ! Collect the currentPair results into the valeVale matrix.
< #ifndef GAMMA
<                if (runCode .eq. 1) then
<                   call kPointLatticeOriginShift (currentNumTotalStates,&
<                         & currentPair,latticeVector,1,currentKPoint-1)
<                   call saveCurrentPair (i,atom2Index,1,currentPair,&
<                         & valeVale,coreValeOL,coreCore)
<                else
<                   call kPointLatticeOriginShift (currentNumTotalStates,&
<                         & currentPair,latticeVector,1,currentKPoint-1)
<                   call saveCurrentPair (i,atom2Index,1,currentPair,&
<                         & valeVale,coreVale,coreCore)
<                endif
< #else
<                if (runCode .eq. 1) then
<                   call saveCurrentPairGamma (i,atom2Index,currentPairGamma,&
<                         & valeValeGamma,coreValeOLGamma,coreCoreGamma)
<                else
<                   call saveCurrentPairGamma (i,atom2Index,currentPairGamma,&
<                         & valeValeGamma,coreValeGamma,coreCoreGamma)
<                endif
< #endif
< 
<                ! Update the atom2Index
<                atom2Index = loopIndices(1,k)
< 
<                ! Reset the currentPair
< #ifndef GAMMA
<                currentPair    (:,:,:) = 0.0_double
< #else
<                currentPairGamma (:,:) = 0.0_double
< #endif
< 
<                ! Update the currentNumTotalStates for the new atom2 index.
<                currentNumTotalStates(2) = atomTypes(atomSites(atom2Index)%&
<                      & atomTypeAssn)%numCoreStates + atomTypes(atomSites&
<                      & (atom2Index)%atomTypeAssn)%numValeStates
< 
<                ! Update the latticeVector
<                call findLatticeVector((atomSites(i)%cartPos(:)-&
<                      & atomSites(atom2Index)%cartPos(:)),latticeVector)
< 
<                ! Apply the phase factor for this cell.
< #ifndef GAMMA
<                call applyPhaseFactors (currentPair,&
<                   & accumulatedIntg(1:currentNumTotalStates(1),&
<                   & accumInitPos+1:accumInitPos+currentNumTotalStates(2)),&
<                   & currentNumTotalStates(1),currentNumTotalStates(2),&
<                   & loopIndices(2,k),runCode,currentKPoint)
< #else
<                call applyPhaseFactorsGamma (currentPairGamma,&
<                   & accumulatedIntg(1:currentNumTotalStates(1),&
<                   & accumInitPos+1:accumInitPos+currentNumTotalStates(2)),&
<                   & currentNumTotalStates(1),currentNumTotalStates(2),&
<                   & loopIndices(2,k),runCode)
< #endif
< 
<             else
<                ! Apply the phase factor for this cell.
< #ifndef GAMMA
<                call applyPhaseFactors (currentPair,&
<                   & accumulatedIntg(1:currentNumTotalStates(1),&
<                   & accumInitPos+1:accumInitPos+currentNumTotalStates(2)),&
<                   & currentNumTotalStates(1),currentNumTotalStates(2),&
<                   & loopIndices(2,k),runCode,currentKPoint)
< #else
<                call applyPhaseFactorsGamma (currentPairGamma,&
<                   & accumulatedIntg(1:currentNumTotalStates(1),&
<                   & accumInitPos+1:accumInitPos+currentNumTotalStates(2)),&
<                   & currentNumTotalStates(1),currentNumTotalStates(2),&
<                   & loopIndices(2,k),runCode)
< #endif
<             endif
< 
<             ! Increment the position within the accumulated data where we begin
<             !   operating on the data.
<             accumInitPos = accumInitPos + currentNumTotalStates(2)
<          enddo
< 
< 
<          ! Collect the currentPair results into the overlap matrix.
< #ifndef GAMMA
<          if (runCode .eq. 1) then
<             call kPointLatticeOriginShift (currentNumTotalStates,&
<                   & currentPair,latticeVector,1,currentKPoint-1)
<             call saveCurrentPair (i,atom2Index,1,currentPair,&
<                   & valeVale,coreValeOL,coreCore)
<          else
<             call kPointLatticeOriginShift (currentNumTotalStates,&
<                   & currentPair,latticeVector,1,currentKPoint-1)
<             call saveCurrentPair (i,atom2Index,1,currentPair,&
<                   & valeVale,coreVale,coreCore)
<          endif
< #else
<          if (runCode .eq. 1) then
<             call saveCurrentPairGamma (i,atom2Index,currentPairGamma,&
<                   & valeValeGamma,coreValeOLGamma,coreCoreGamma)
<          else
<             call saveCurrentPairGamma (i,atom2Index,currentPairGamma,&
<                   & valeValeGamma,coreValeGamma,coreCoreGamma)
<          endif
< #endif
<       enddo
< 
<       ! Close the HDF property lists for this atom.
<       call h5pclose_f (fileIntg_plid,hdferr)
<       if (hdferr == -1) stop 'Failed to close file intg plid'
<       call h5pclose_f (fileLoopIndices_plid,hdferr)
<       if (hdferr == -1) stop 'Failed to close file loop indices plid'
< 
<       ! Close the HDF datasets for this atom.
<       call h5dclose_f (intg_did,hdferr)
<       if (hdferr == -1) stop 'Failed to close intg did'
<       call h5dclose_f (loopIndices_did,hdferr)
<       if (hdferr == -1) stop 'Failed to close loop indices did'
< 
<       ! Close the HDF dataspaces for this atom.
<       call h5sclose_f (fileIntg_dsid,hdferr)
<       if (hdferr == -1) stop 'Failed to close intg dsid'
<       call h5sclose_f (fileLoopIndices_dsid,hdferr)
<       if (hdferr == -1) stop 'Failed to close loop indices dsid'
< 
<       ! Deallocate the chunks for this i loop atom.
<       deallocate (accumulatedIntg)
<       deallocate (loopIndices)
<    enddo
< 
<    ! Deallocate matrices that are not necessary any more.
< #ifndef GAMMA
<    deallocate (currentPair)
< #else
<    deallocate (currentPairGamma)
< #endif
< 
<    ! Close the dataspace that was used for the data memory dataset.
<    call h5sclose_f (dataChunk_dsid,hdferr)
<    if (hdferr == -1) stop 'Failed to close data chunk dsid'
< 
<    ! Close the dataspace that was used for the loop index memory dataset.
<    call h5sclose_f (loopIndices_dsid,hdferr)
<    if (hdferr == -1) stop 'Failed to close loop indices dsid'
< 
<    ! Close the integral file access property list.
<    call h5pclose_f (intg_plid,hdferr)
<    if (hdferr == -1) stop 'Failed to close intg plid'
< 
<    ! Close the HDF integral file.
<    call h5fclose_f (intg_fid,hdferr)
<    if (hdferr == -1) stop 'Failed to close intg file'
< 
< 
<    ! Form the valeVale matrix
<    ! Determine which matrices are to be made and used.  The overlap matrix is
<    !   treated slightly differently than the others.
< #ifndef GAMMA
<    if (runCode .eq. 1) then
<       if (coreDim /= 0) then
<          ! Obtain the orthogonalization coefficients.  (coreValeOL)
<          call valeCoreCoreValeOL (valeDim,coreDim,valeVale(:,:,1),&
<                & coreValeOL(:,:,1))
< 
<          ! Allocate the valeCore matrix.
<          allocate (valeCore (coreDim,valeDim))  ! Pre-transposed format
< 
<          ! Form a product of (coreValeOL)(coreCore) in a temp matrix
<          !   (valeCore).
<          call coreValeCoreCore (valeDim,coreDim,valeCore,coreValeOL(:,:,1),&
<                & coreCore(:,:,1))
< 
<          ! Deallocate the coreCore and allocate the packedValeVale.
<          deallocate (coreCore)
<          allocate (packedValeVale(2,valeDim*(valeDim+1)/2))
< 
<          ! Finally compute the product of the above (valeCore)(coreCore) with
<          !   coreValeOL.  This is added to valeVale to complete
<          !   orthogonaliziation.
<          call makeValeVale (valeDim,coreDim,valeDim,valeCore, &
<                & coreValeOL(:,:,1),valeVale(:,:,1),packedValeVale,1,0)
< 
<          ! Save the overlap valeVale only if it is requested.  (This will be
<          !   most of the time.  It is only not saved when we are doing a SYBD
<          !   type of calculation when we have some 300 kpoints.)  This is
<          !   also why this question is not asked for the Gamma kpoint
<          !   situation below.
<          if (noSaveValeVale == 0) then
<             call h5dwrite_f (valeValeBand_did,H5T_NATIVE_DOUBLE,&
<                   & packedValeVale(:,:),valeValeBand_dims,hdferr)
<             if (hdferr == -1) stop 'Failed to write packed vale vale band'
<          endif
< 
<          ! Deallocate packedValeVale and valeCore to be ready for next kp.
<          deallocate (packedValeVale)
<          deallocate (valeCore)
<       else  ! No core dim in whole system so orthogonalization is not needed.
<          deallocate (coreCore)
<          if (noSaveValeVale == 0) then
<             allocate (packedValeVale(2,valeDim*(valeDim+1)/2))
< 
<             ! Initialize the index counter for packing.
<             currIndex = 0
< 
<             ! Pack the valeVale matrix.
<             do j = 1, valeDim
<                do k = 1, j
<                   currIndex = currIndex + 1
<                   packedValeVale(1,currIndex) = &
<                         & real(valeVale(k,j,1),double)
<                   packedValeVale(2,currIndex) = aimag(valeVale(k,j,1))
<                enddo
<             enddo
< 
<             call h5dwrite_f (valeValeBand_did,H5T_NATIVE_DOUBLE,&
<                   & packedValeVale(:,:),valeValeBand_dims,hdferr)
<             if (hdferr == -1) stop 'Failed to write packed vale vale band'
<             deallocate (packedValeVale)
<          endif
<       endif
<    else
<       if (coreDim /= 0) then
<          ! Modify the overlap with the valeCoreCoreValeOL matrix multiplication.
<          call valeCoreCoreVale (valeDim,coreDim,valeVale(:,:,1),&
<                & coreVale(:,:,1),coreValeOL(:,:,1))
< 
<          ! Deallocate the coreVale matrix and allocate the valeCore matrix.
<          deallocate (coreVale)
<          allocate (valeCore (coreDim,valeDim)) ! Pre-transposed format.
< 
<          ! Form a product of (coreValeOL)(coreCore) in a temp matrix (valeCore).
<          call coreValeCoreCore (valeDim,coreDim,valeCore,coreValeOL(:,:,1),&
<                & coreCore(:,:,1))
< 
<          ! Finally compute the product of the above (valeCore)(coreCore) with
<          !   coreValeOL.  This is added to valeVale to complete
<          !   orthogonaliziation.  Note that the final 1 is used to indicate
<          !   that the full matrix should be created for faster cache access
<          !   later on.  This is only necessary for the momentum matrix elements.
<          allocate (packedValeVale(2,1)) ! Unused but needed for completeness.
<          if (runCode == 2) then
<             call makeValeVale (valeDim,coreDim,1,valeCore,coreValeOL(:,:,1),&
<                   & valeVale(:,:,1),packedValeVale,0,0)
<          else
<             call makeValeVale (valeDim,coreDim,1,valeCore,coreValeOL(:,:,1),&
<                   & valeVale(:,:,1),packedValeVale,0,1)
<          endif
<          deallocate (packedValeVale)
< 
<          ! Deallocate temporary matrices.
<          deallocate (valeCore)
<          deallocate (coreCore)
<       else  ! The valeVale is already made, no need to orthogonalize.
<          ! However, the momentum matrix needs to be made into a full matrix,
<          !   not just the upper triangle.
<          if (runCode /= 2) then
<             do i = 1, valeDim
<                do j = 1, i
<                   valeVale(i,j,1) = conjg(valeVale(j,i,1))
<                enddo
<             enddo
<          endif
< 
<          deallocate (coreVale)
<          deallocate (coreCore)
<       endif
<    endif
< #else
<    if (runCode .eq. 1) then
<       if (coreDim /= 0) then
<          ! Obtain the orthogonalization coefficients.  (coreValeOL)
<          call valeCoreCoreValeOLGamma (valeDim,coreDim,valeValeGamma,&
<                & coreValeOLGamma)
< 
<          ! Allocate the valeCore matrix in a transposed format for much more
<          !   efficient cache usage during the matrix multiplication.
<          allocate (valeCoreGamma (coreDim,valeDim))
<    
<          ! Form a product of (coreValeOL)(coreCore) in a temp matrix
<          !   (valeCore).
<          call coreValeCoreCoreGamma (valeDim,coreDim,valeCoreGamma,&
<                & coreValeOLGamma,coreCoreGamma)
< 
<          ! Deallocate the coreCore and allocate the packedValeVale.
<          deallocate (coreCoreGamma)
<          allocate (packedValeVale(1,valeDim*(valeDim+1)/2)) ! Deallocated
<                ! after the getIntgResults subroutine is called from band.f90.
<                ! This portion is only run from calls from that program.
<    
<          ! Finally compute the product of the above (valeCore)(coreCore) with
<          !   coreValeOL.  This is added to valeVale to complete
<          !   orthogonaliziation.
<          call makeValeValeGamma (valeDim,coreDim,valeDim,valeCoreGamma,&
<                & coreValeOLGamma,valeValeGamma,packedValeVale,1,0)
< 
<          ! Save the overlap valeVale
<          call h5dwrite_f (valeValeBand_did,H5T_NATIVE_DOUBLE,&
<                & packedValeVale(:,:),valeValeBand_dims,hdferr)
<          if (hdferr == -1) stop 'Failed to write vale vale band overlap'
< 
<          ! Deallocate temporary matrices to be ready for the next kpoint.
<          deallocate (packedValeVale)
<          deallocate (valeCoreGamma)
<       else  ! No core dimension in the whole system.
<          deallocate (coreCoreGamma)
<          if (noSaveValeVale == 0) then
<             allocate (packedValeVale(1,valeDim*(valeDim+1)/2))
< 
<             ! Initialize the index counter for packing.
<             currIndex = 0
< 
<             ! Pack the valeVale matrix.
<             do j = 1, valeDim
<                do k = 1, j
<                   currIndex = currIndex + 1
<                   packedValeVale(1,currIndex) = valeValeGamma(k,j)
<                enddo
<             enddo
< 
<             call h5dwrite_f (valeValeBand_did,H5T_NATIVE_DOUBLE,&
<                   & packedValeVale(:,:),valeValeBand_dims,hdferr)
<             if (hdferr == -1) stop 'Failed to write packed vale vale band'
<             deallocate (packedValeVale)
<          endif
<       endif
<    else
<       if (coreDim /= 0) then
<          call valeCoreCoreValeGamma (valeDim,coreDim,valeValeGamma,&
<                & coreValeGamma,coreValeOLGamma)
< 
<          ! Deallocate the coreVale matrix and allocate the valeCore matrix
<          !   in a transposed format for much more efficient cache usage
<          !   during the matrix multiplication.
<          deallocate (coreValeGamma)
<          allocate (valeCoreGamma (coreDim,valeDim))
< 
<          ! Form a product of (coreValeOL)(coreCore) in a temp matrix
<          !   (valeCore).
<          call coreValeCoreCoreGamma (valeDim,coreDim,valeCoreGamma,&
<                & coreValeOLGamma,coreCoreGamma)
< 
<          ! Finally compute the product of the above (valeCore)(coreCore) with
<          !   coreValeOL.  This is added to valeVale to complete
<          !   orthogonaliziation.  Note that the final 1 is used to indicate
<          !   that the full momentum matrix should be stored instead of just
<          !   the upper triangle for the purpose of faster cache access later
<          !   on.
<          allocate (packedValeVale(2,1)) ! Unused, but necessary parameter.
<          if (runCode == 2) then
<             call makeValeValeGamma (valeDim,coreDim,1,valeCoreGamma,&
<                   & coreValeOLGamma,valeValeGamma,packedValeVale,0,0)
<          else
<             call makeValeValeGamma (valeDim,coreDim,1,valeCoreGamma,&
<                   & coreValeOLGamma,valeValeGamma,packedValeVale,0,1)
<          endif
<          deallocate (packedValeVale)
< 
<          ! Deallocate temporary matrices.
<          deallocate (valeCoreGamma)
<          deallocate (coreCoreGamma)
<       else  ! The valeVale is already made, no need to orthogonalize.
<          ! However, the momentum matrix needs to be made into a full matrix,
<          !   not just the upper triangle.
<          if (runCode /= 2) then
<             do i = 1, valeDim
<                do j = 1, i
<                   valeValeGamma(i,j) = valeValeGamma(j,i)
<                enddo
<             enddo
<          endif
< 
<          deallocate (coreValeGamma)
<          deallocate (coreCoreGamma)
<       endif
<    endif
< #endif
< 
< end subroutine getIntgResults
< 
< 
< end module O_IntegralsPSCF
---
> end subroutine saveCurrentAccumulation
