#!/usr/bin/env perl

sub printHelp
{
   print <<ENDHELP;
#############################################################################
# PROGRAM: EnsembleCondense
# PURPOSE: This program will run an ensemble of precondensation and Lammps 
#          condensation. It will create several packmol files(precondensations) 
#          by calling another script called condense and derive the Lammps data 
#          file for each of those then run a Lammps condesation.
#
# USAGE:   ensembleCondense [-i \$inputFile] [-n \$numSimulations]
#                           [-c \$numComposition] [-r \$numReactions] | [-help]
#
# The -i option can be used to specify the name of the input file (\$inputFile).
#   If this option is not given then a default value of "ensemble.in" will be
#   used.
# The -n \$numSimulations option can be used to define the size of the ensemble
#   by giving the number of simultaneous simulations (\$numSimulations). If
#   this option is not provided, then a default value of 20 will be used.
#############################################################################
ENDHELP
   exit(0);
}

###############################################
# Begin program execution #####################
###############################################

# Use necessary modules.
use strict;
use warnings;
use v5.16.3;
use LWP::Simple;
use Parallel::ForkManager;
use POSIX qw(ceil floor);
use Env;
use lib "$OLCAO_BIN/perl5";
use StructureControl;
use ElementData;
use BondData;
use AngleData;
use File::Copy;


# Declare Global Variables.
my $inputFile; # Base input file for generating ensembles.
my $numSimulations; # Number of the simulations to be run at a time.
my $numCompositions; # Number of atomic bond types.
my $numReactions; # Number of different types of reactions.
my $numMoleculeTypes;
my $numReactionTypes;
my @numMolecules;
my @moleculeName;
my @bindingType;
my $maxCellSize;
my $minCellSize;
my @rxnMolName;
my @rxnBinding;
my @rxnMinProbability;
my @rxnMaxProbability;
my $pm;
my $C = 0;
my $probabilityB;
my $mol=0;

# Initialize the environment.
&initEnv;

# Read the command line parameters.
&parseCommandLine;

# Read the main input file.
&parseInputFile;

## Error check the input for consistency.
#&errorCheckInput;

## Compute implicit information not explicitly given in the input file.
#&computeImplicitInput;

# Generate initial ensemble.
&initEnsemble;

# Test parallelization.
&runParallelCondense;

# Get Steoichiometry
#&stoichiometry;

# Start evolutionary algorithm.
&evolveEnsemble;

# Process the final output.
&processResults;

###############################################
# End program execution #######################
###############################################


sub initEnv
{
   # Define default values for command line parameters.
   $inputFile = "ensemble.in";
   $numSimulations = 2;
   $numCompositions = 0;
   $numReactions = 0;
}


# Loop through the command line parameters checking for each option.
sub parseCommandLine
{
   # Define local variables.
   my $number; # A simple counter for tracking which command line parameter we
               #   are currently on during the search through @ARGV.
   my $argument;


   # Read the command line parameters.
   $number = 0;
   while ($number < scalar(@ARGV))
   {
      if ($ARGV[$number] eq "-help")
         {&printHelp;}
      elsif ($ARGV[$number] eq "-i")
         {$inputFile = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-n")
         {$numSimulations = $ARGV[++$number];}
      else
      {
         print STDOUT "UNKNOWN COMMAND LINE PARAMETER $ARGV[$number].";
         print STDOUT " ABORTING.\n";
         exit;
      }
      $number++;
   }

   # Record the command line used to run this job.
   open (COMMANDLINE,">>command");
   print COMMANDLINE "ensembleCondense ";
   foreach $argument (0..$#ARGV)
      {print COMMANDLINE "$ARGV[$argument] ";}
   print COMMANDLINE "\n";
   close (COMMANDLINE);
}

sub parseInputFile
{

   # Define local variables.
   my $mol;
   my $rxn;
   my $line;
   my @values;
   my $sim;
   my $rxnMinProbability;
   my $rxnMaxProbability;

   $C = $minCellSize;

   # Open the input file.
   open (INFILE,"<$inputFile")
         || die "Cannot open $inputFile for reading. \n";


   #Read the input file.
   while ($line = <INFILE>)

   {
      @values = StructureControl::prepLine("",$line,'\s+');
      #print STDOUT "@values\n";

      # Look for "composition", "cell_size", and "reactions" key words.
      if (lc($values[0]) eq "num_models")

      {
        $numSimulations = $values[1];
      }
      elsif (lc($values[0]) eq "composition")
      {  
         $numMoleculeTypes = $values[1];

         foreach $mol (1..$numMoleculeTypes)
         {
            @values = StructureControl::prepLine(\*INFILE,"",'\s+');
            $moleculeName[$mol] = lc($values[0]);
            $bindingType[$mol] = lc($values[1]);
            $numMolecules[$mol] = $values[2];
            #print STDOUT "@values\n";
         }
      }
      elsif (lc($values[0]) eq "cell_size")
      {
         $minCellSize = $values[1];
         $maxCellSize = $values[2];
      }
      elsif (lc($values[0]) eq "reactions")
      {
         # Get the number of different types of reactions.
         $numReactionTypes = $values[1];

         # Read the descriptor for each reaction that includes the name of each
         #   of the participating molecules and the type of binding that each
         #   molecule makes available for that reaction to occur.
         foreach $rxn (1..$numReactionTypes)
         {
            @values = StructureControl::prepLine(\*INFILE,"",'\s+');
            $rxnMolName[1][$rxn] = lc($values[0]);
            $rxnBinding[1][$rxn] = lc($values[1]);
            $rxnMolName[2][$rxn] = lc($values[2]);
            $rxnBinding[2][$rxn] = lc($values[3]);
            $rxnMinProbability[$rxn] = $values[4];
            $rxnMaxProbability[$rxn] = $values[5];
            print STDOUT "@values\n";
         }
      }
   }
}
#composition 3
#B10C2H12 B-1 6
#CH4 C-1 2
#CH3CH3 C-1 1
#
#cell_size $C
#
#reactions 3
#B10C2H12 B-1 B10C2H12 B-1 0.85
#B10C2H12 B-1 CH4 C-1 0.85
#B10C2H12 B-1 CH3CH3 C-1 0.75

sub initEnsemble
{
   # Define local variables.

   # my $mol;
   my $sim;
   my $C = $minCellSize;
   $probability = $rxnMinProbability[1];
    
   my $pm = Parallel::ForkManager->new($numSimulations);

   foreach $sim (1..$numSimulations)
   {
      $pm->start and next;
      $C = $minCellSize + ($maxCellSize - $minCellSize)/($numSimulations-1)*($sim-1);
      $probability =  $rxnMinProbability[1] + ($rxnMaxProbability[1] - $rxnMinProbability[1])/($numSimulations-1)*($sim-1);
      #$probabilityC =  $rxnMinProbability[1] + ($rxnMaxProbability[1] - $rxnMinProbability[1])/($numSimulations-1)*($sim-1);
      #$probabilityH =  $rxnMinProbability[1] + ($rxnMaxProbability[1] - $rxnMinProbability[1])/($numSimulations-1)*($sim-1);
      say "Hello World $sim\n";
      mkdir "$sim";
      chdir "$sim";
      open (INP,">condense.in") || die "Cannot open condense.in for writing.\n";

      print INP "composition $numMoleculeTypes\n";
      foreach $mol (1..$numMoleculeTypes)
      {
      print INP "$moleculeName[$mol] family1 $numMolecules[$mol]\n";
      }
      print INP "\ncell_size $C\n\n";
      print INP "reactions $numReactionTypes\n";
      foreach $mol (1..$numMoleculeTypes)
      {
      print INP "$moleculeName[$mol] $bindingType[$mol] $moleculeName[$mol] $bindingType[$mol] $probability\n";
      }

     chdir("..");
     $pm->finish;
   
   }
say "I am after the loop\n";
$pm->wait_all_children;

}

sub runParallelCondense
{
   # Define local variables.
   my $sim;
   my $out;

   foreach $sim (1..$numSimulations)
   {
      chdir ("$sim");
      system("condense");
      chdir ("lammps");
      $out = `srun -N 1 -c 1 lmp < lammps.in`;
      system("dump2skl -d dump.coarse -a lammps.dat -t $timestep");
      #open the olcao skleton file for reading
      open (OLC, "<$inputFile_olcao")
              || die "cannot open $inputFile_olcao for reading. \n";
      #read the input file (olcoa.skl)
      while ($line = <OLC>)
      {
       @values = StructureControl::prepLine("",$line,'\s+');
       # Look for atom names
       if (lc($values[0]) =~ "frac")
       {
          $numAtoms = $values[1];
           foreach $atom (1..$numAtoms)
           {
             @values = StructureControl::prepLine(\*OLC,"",'\s+');
             $elements_keys = $values[0];
             if (exists($arr_sim[$sim]{$elements_keys}))
             {
                $arr_sim[$sim]{$elements_keys}+=1;
             }
             else
             {
                $arr_sim[$sim]{$elements_keys} = 1;
             }
           }
        }
       }
         # Calculate the elements percentage in each model
         foreach $elements_keys (keys $arr_sim[$sim])
         {
           if (lc($elements_keys) eq lc($target_element))
           {  
             print "Number of $elements_keys in model $sim is $arr_sim[$sim]{$elements_keys}\n";
             $percentage = ($arr_sim[$sim]{$elements_keys}/$numAtoms)*100;
             print "the percentage of $elements_keys in model $sim is $percentage\n";
             $h_diff = abs ($percentage - $target_element_percentage);
             $hydrogen_arr[$sim-1]=$h_diff;
             #Note to self: Remember to add a success criteria, don't keep killing half of them if you can keep them.
             print "Array of Hydrogen is @hydrogen_arr\n";
                         
            # @sorted_hydrogen_arr = sort {$hydrogen_arr[$a] <=> $hydrogen_arr[$b]} 1..$#hydrogen_arr;
             
             #$number_ofmodels_tokill= $numSimulations*$killing_rate/100;
             #$first = $numSimulations - $number_ofmodels_tokill;
             #@models_to_kill= @sorted_hydrogen_arr[$first..$#sorted_hydrogen_arr];
           }
         }
     chdir ("../..");
    }
      while (scalar(@arr_sim) > 0)
         {shift @arr_sim;}
             @sorted_hydrogen_arr = sort {$hydrogen_arr[$a] <=> $hydrogen_arr[$b]} 0..$#hydrogen_arr;
              foreach $i (0..$#sorted_hydrogen_arr)
             {
              $sorted_hydrogen_arr[$i] = $sorted_hydrogen_arr[$i]+1

              }
 
             $number_ofmodels_tokill= $numSimulations*$killing_rate/100;
             $first = $numSimulations - $number_ofmodels_tokill;
             @models_to_kill= @sorted_hydrogen_arr[$first..$#sorted_hydrogen_arr];
             
             #$unsuccessful = 
 #while (scalar(@models_to_kill) > 0)
 #{
   foreach $sim (@models_to_kill)
     {
        chdir ("$sim");
        open (INP,"<condense.in") || die "Cannot open condense.in for reading.\n";
        @content_of_condense = <INP>;
        close (INP);
               print "content equal @content_of_condense\n";
        print "content 7 equal $content_of_condense[6]\n";
        if ($target_element_percentage - $percentage > 0)
         #I need to limit the probability to 1 and 0, it takes 10 itereations to reach 1 from a zero, in case we do more than 10 generations the probability will end up more than 1, use a while loop.
        {
          $probability = $probability + 0.1;
          
         }
         else 
         {
          $probability = $probability - 0.1;
          } 
          $content_of_condense[6] = "ch4_1 c-1 ch4_1 c-1 $probability";
           open (INP,">condense.in") || die "Cannot open condense.in for writing. \n";
           print INP "@content_of_condense";
           close (INP);
           chdir ("..");
     }
 #}
#}
print "Sorted array is @sorted_hydrogen_arr\n";


   foreach $sim (1..$numSimulations)
   {
      chdir ("$sim/lammps");
      #system ("lammps");
      $out = `srun -N 1 -c 1 lmp < lammps.in`;
      system("dump2skl -d dump.coarse -a lammps.dat -t 500");
      chdir ("../..");
      #wait();
   }
}
print "$target_element_percentage\n";
}
#}
sub evolveEnsemble
{
}

 
sub processResults
{
}

