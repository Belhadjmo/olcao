#!/usr/bin/env perl

sub printHelp
{
   print <<ENDHELP;
# PROGRAM: makeReactions
# PURPOSE: To create a set of pre- and post-reaction molecule files along with
#    a mapping file for a bond/react based LAMMPS calculation.
# ALGORITHM: This program requires two directories as input that each identify
#    a precursor molecule type. It will then create a new directory based on
#    the combination of their names. Inside that new directory, it will copy
#    OLCAO skeleton input files from the originally identifies directories and
#    will then process them to create pre- and post-reaction files along with
#    a mapping file.
#
#    Each file is parsed to find and record all of its H atoms and the atoms
#    bonded to the H atoms. It is assumed that the H atoms between the two
#    molecules will be the points at which new bonds will be formed. That is,
#    the H atoms will break off to form H_2 and the remaining bare atoms will
#    bond.
#
#    Once all the atoms in both molecules have been cataloged, then the second
#    molecule will be systematically translated and oriented so that each of
#    its H atoms would be in a proper position for reacting with each of the H
#    atoms in the first molecule. Once so translated and rotated, then the
#    skeleton files for molecule1 and the modified molecule2 will be merged
#    into a single file.
#
#    At this point two product files are created that are suitable molecule
#    files for use in LAMMPS bond/react calculations. The first is the
#    pre-reaction molecule file that contains relevant segments of both
#    molecules (where "relevant" is determined by the chain-length variable
#    which is 2 by default so as to include the atoms bonded to the H atoms
#    and the next nearest neighbor atoms). The second is the post-reaction
#    molecule.
#
#    The atomic structure (number of atoms and their coordiates) are the same
#    in both files. The difference is that additional information about their
#    bonding patterns is different. When it is time for both the pre- and
#    post-reaction LAMMPS files to be created the OLCAO skeleton file
#    containing the merged pair of molecules is read, bonds and bond angles are
#    analyzed, and a subset of the original atoms from the skeleton file are
#    taken according to a chain-length variable.
#
#    Note that the subset will *not* include the bonding H atoms. The
#    simulation will ultimately consist of molecules with sites where there are
#    "missing" H atoms. Presently, the bond/react fix in LAMMPS will not permit
#    a complicated series of reactions whereby the H from each molecule breaks
#    off to form H_2 and the molecules can subsequently bind. Instead we will
#    run the simulation with molecules where the H is already absent by
#    construction so that molecule binding can only occur at those pre-defined
#    sites.
#
# The -d1 option defines the name of the first molecule directory that must
#    contain an OLCAO skeleton input file. The -d2 does the same for the second
#    molecule directory. IMPORTANT: An extremely important assumption is that
#    each molecule given in a skeleton file uses space group 1_a. I.e., all
#    atomic coordinates should be specified explicitly. Additionally, they
#    should be given in cartesian coordiantes. This option is required. There
#    are no default values that can be assumed. Also note that the order of
#    molecules is not important because they will be sorted so that the -d1
#    molecule is always alphanumerically before the -d2 molecule.
# The -c1 option defines the chain length variable \$chainLen1 that is used to
#    reduce (prune) the number of atoms in the full molecules. That action will
#    save time during a LAMMPS simulation when it seeks reaction template
#    matches. This variable defines the number of atoms (starting at the point
#    of "contact" between the two molecules) to include in the reaction
#    template from molecule 1. The -c2 option defines the same for molecule 2.
#    This does not include the point of contact atoms. So, if the binding
#    If the molecules are CH4 and B10C2H12 and the contact points are an H atom
#    bound to the C atom from CH4 and a B or a C atom from B10C2H12. Then a
#    -c1 of 3 would include the H atom bound to the central C atom, the central
#    C atom of the CH4 itself, and all three other H atoms. A -c2 of 2 would
#    include the H atom bound to either a B or C atom then the B or C atom
#    itself. Further, a -c2 of 3 would additionally include each of the
#    neighboring B or C atoms to the bound B or C atom. By default the chain
#    length values are set to 3 for both molecules.
# The -h option defines the distance that H atoms will be separated from each
#    other when the templates are created. By default the H atom separation is
#    0.5. It is assumed that when the pre- and post-reaction molecule files are
#    created the H atoms that are "in contact" with each other will not be
#    included.
# The -help option gives this help.
#
# USAGE: makeReactions -d1 \$inDir1 -d2 \$inDir2
#                      [-c1 \$chainLen1] [-c2 \$chainLen2]
#                      [-h \$hhDist]
#                      [-help]
#
ENDHELP
   exit;
}

###############################################
# Begin program execution #####################
###############################################

# Use necessary modules.
use strict;
use warnings;
use POSIX qw(ceil floor);
use Env;
use lib "$OLCAO_BIN/perl5";
use StructureControl;
use ElementData;
use Math::Trig;
use File::Copy;

# Declare global variables.
my $pi = 3.1415926535897932384626433832795;
my $epsilon = 0.00001;
my $inDir1;       # Directory containing the first molecule.
my $inDir2;       # Directory containing the second molecule.
my $rxnDir;       # Directory for the reaction between molecules 1 and 2.
my $inFile1;      # First molecule input skeleton file.
my $inFile2;      # Second molecule input skeleton file.
my $inFileCent1;  # First molecule skeleton file with spatially centered mol.
my $inFileCent2;  # Second molecule skeleton file with spatially centered mol.
my $chainLen1;    # Number of atoms to include in a template from a whole mol.
my $chainLen2;    # Same as above except for molecule 2.
my $numAtoms1;    # Number of atoms in molecule 1.
my $numAtoms2;    # Number of atoms in molecule 2.
my $numHAtoms1;   # Number of H atoms in the first molecule.
my $numHAtoms2;   # Number of H atoms in the second molecule.
my @hAtomCoords1; # Coordinates of those H atoms in the first molecule.
my @hAtomCoords2; # Coordinates of those H atoms in the second molecule.
my @bondedCoords1;# Coordinates of the atoms bonded to the H in the first mol.
my @bondedCoords2;# Coordinates of the atoms bonded to the H in the second mol.
my @hAtomNumber1; # Atom number of the H atoms in mol 1.
my @hAtomNumber2; # Atom number of the H atoms in mol 2.
my @mergedHAtomNumber1; # Atom number of H atoms in the merged molecule.
my @mergedHAtomNumber2; # Atom number of H atoms in the merged molecule.
my @prunedHAtomNumber1; # Atom number of H atoms in the pruned merged molecule.
my @prunedHAtomNumber2; # Atom number of H atoms in the pruned merged molecule.
my @bondedAtomNumber1; # Atom num of atom bonded to H in mol 1 and merged mol.
my @bondedAtomNumber2; # Atom num of atom bonded to H in mol 2 and merged mol.
my @bondedElemName1; # Element name of the atom bonded to H in mol1 & merged.
my @bondedElemName2; # Element name of the atom bonded to H in mol2 & merged.
my @bondedSpecies1; # Species number of the atom bonded to H in mol1 & merged.
my @bondedSpecies2; # Species number of the atom bonded to H in mol2 & merged.
my @prunedBondedAtomNumber1;# Num of atom bonded to H(A,B) in pruned merged mol.
my @prunedBondedAtomNumber2;# Num of atom bonded to H(A,B) in pruned merged mol.
my @prunedBondedElemName1; # Element name of atom bonded to H(A,B) in pruned.
my @prunedBondedElemName2; # Element name of atom bonded to H(A,B) in pruned.
my @prunedBondedSpecies1; # Species number of atom bonded to H(A,B) in pruned.
my @prunedBondedSpecies2; # Species number of atom bonded to H(A,B) in pruned.
my $hhDist;       # The H-H distance in the templates.
my $numBonds_ref; # The number of bonds that a given atom has.
my $bonded_ref;   # The atom numbers that each atom is bonded to.
my $numBondAngles_ref; # Number of bond angles for each atom.
my $angleBonded_ref; # The atom numbers that the vertex atoms are bonded to.
my @keepAtom;     # List of which atoms in the merged molecule to keep.
my @prunedNumAtoms; # For each hh pair, the number of atoms left in the mol.
my @prunedNumAtoms1; # For each hh pair, the number of atoms left in sub-mol. 1
my @prunedNumAtoms2; # For each hh pair, the number of atoms left in sub-mol. 2
my $directXYZ_ref;
my $bondLength_ref;
my $atomElementName_ref;
my $atomSpeciesID_ref;
my $numUniqueAngleTags;
my $numUniqueBondTags;
my $uniqueAngleTags_ref;
my $angleTagID_ref;
my $numAnglesTotal;
my $bondTagID_ref;
my $uniqueBondTags_ref;
my @edgeID; # Atom IDs from the pre-reacted template without all topology.
my @prunedEdgeID; # As above, but with ID numbers mapped to the pruned template.
my @numEdgeIDs; # Number of such atoms.

# Initialize the environment.
&initEnv;

# Read the command line parameters.
&parseCommandLine;

# Finalize the environment on the basis of required input parameters.
&finalizeEnv;

# Prepare the molecules by creating skeleton files with the molecules centered
#   in each of their respective cells and by ensuring that each cell is
#   sufficiently large to accomodate both molecules at their fullest possible
#   extension in all directions and orientations.
&prepMolecules;

# Catalog the positions of the H atoms and their bound neighbors in both mols.
&catalogH(1,$inFileCent1,\@hAtomCoords1,\@bondedCoords1,\@hAtomNumber1,
          \@bondedAtomNumber1,\@bondedElemName1,\@bondedSpecies1);
&catalogH(2,$inFileCent2,\@hAtomCoords2,\@bondedCoords2,\@hAtomNumber2,
          \@bondedAtomNumber2,\@bondedElemName2,\@bondedSpecies2);

# Print a set of centered skeleton file versions of the two molecules where the
#   individual and reactive H atoms have been removed from each molecule one at
#   a time. Then, convert the skeleton files to PDB format for inclusion in a
#   packmol run.
#&generatePackmolPDBs($inFileCent1,$mol1Name,$numAtoms1,$numHAtoms1,
#   \@bondedAtomNumber1,\@hAtomNumber1);
#&generatePackmolPDBs($inFileCent2,$mol2Name,$numAtoms2,$numHAtoms2,
#   \@bondedAtomNumber2,\@hAtomNumber2);

# Generate a set of merged molecule files with different orientations.
&generateMergedMols;

# Remove atoms that are far from the bond reaction point.
&pruneMergedMolecule;

# Build LAMMPS bond/react templates from the pruned olcao.skl files. There are
#   four phases to a complete reaction: (a) Lead H atoms bond. (b) One lead H
#   atom breaks from its home molecule. (c) The other lead H atom breaks from
#   its home molecule. (d) The atoms that were bonded to the H atoms create a
#   bond between themselves. Each phase requires a pre-template, a
#   post-template, and a mapping file.
# The terminology and notation is a bit tricky here so I will clarify. Each
#   phase described above will be called a "reaction" by the bond/react fix in
#   lammps. There will thus be four reaction template pairs labeled a, b, c, d
#   as above.
&makeReactionTemplates(1); # Pre-reaction "a" templates.
&makeReactionTemplates(2); # Post-reaction "a" templates.
&makeReactionTemplates(3); # Pre-reaction "b" templates.
&makeReactionTemplates(4); # Post-reaction "b" templates.
&makeReactionTemplates(5); # Pre-reaction "c" templates.
&makeReactionTemplates(6); # Post-reaction "c" templates.
&makeReactionTemplates(7); # Pre-reaction "d" templates.
&makeReactionTemplates(8); # Post-reaction "d" templates.

###############################################
# End program execution #######################
###############################################

sub initEnv
{
   # Define local variables.
   my @values;
   my $basename;
   my $pwd;

   # Initialize parameter defaults.
   $chainLen1 = 3;
   $chainLen2 = 3;
   $hhDist = 0.5;
}

sub parseCommandLine
{
   # Declare local variables
   my $number;
   my $argument;
   my $commandLine = "command";

   # Initialize the index counter for the command line parameters.
   $number=0;

   # Loop through the command line parameters checking for each option.
   while ($number < scalar(@ARGV))
   {
      if ($ARGV[$number] eq "-help")
         {&printHelp;}
      elsif ($ARGV[$number] eq "-d1")
         {$inDir1 = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-d2")
         {$inDir2 = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-c1")
         {$chainLen1 = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-c2")
         {$chainLen2 = $ARGV[++$number];}
      else
      {
         print STDOUT "UNKNOWN COMMAND LINE PARAMETER $ARGV[$number].";
         print STDOUT " ABORTING.\n";
         exit;
      }
      $number++;
   }

   #Record the command line used to create this set of input files.
   open (COMMANDLINE,">>$commandLine");
   print COMMANDLINE "makeReactions ";
   foreach $argument (0..$#ARGV)
      {print COMMANDLINE "$ARGV[$argument] ";}
   print COMMANDLINE "\n";
   close (COMMANDLINE);
}

sub finalizeEnv
{
   # Define temporary variables.
   my $tempName;

   # Arrange the order of the molecules.
   if ("$inDir1" ge "$inDir2")
   {
      $tempName = $inDir1;
      $inDir1 = $inDir2;
      $inDir2 = $tempName;
   }

   # Define the reaction directory name.
   $rxnDir = $inDir1 . "__" . $inDir2;

   # Make the reaction directory (where we will stay for the
   #   remainder of the script execution).
   mkdir ("$rxnDir");

   # Establish variables that refer to the input skeleton files.
   $inFile1 = $inDir1 . ".skl";
   $inFile2 = $inDir2 . ".skl";

   # Copy the molecule skeleton files into the reaction directory. (Note that
   #   if inFile1 and inFile2 are actually the same, then the second one will
   #   be copied over the first. This is okay.)
   copy ("$inDir1/$inFile1", "$rxnDir");
   copy ("$inDir2/$inFile2", "$rxnDir");

   # Enter into the reaction template directory.
   chdir ("$rxnDir");
}

sub prepMolecules
{
   # Define local variables.
   my @values;
   my $systemTitle_ref;
   my $systemTitle;
   my $mag_ref;
   my @sortedMag;
   my $maxSide1;
   my $maxSide2;

   # Okay, the sequence of activity here is a bit tricky and convoluted because
   #   there are limits to what kinds of information we have access to at
   #   each stage. Also, we don't want to write a lot of custom code if we can
   #   get away with just using existing subroutines from StructureControl.

   # At the end of this subroutine, we will want each molecule to be in a new
   #   skeleton file. The molecules will be centered in the simulation cells.
   #   Also, the sizes of the simulation cells will be such that the full
   #   breadth of both molecules in any direction can be contained. (That is
   #   the slightly annoying part.) To make that happen, we need to know
   #   something about *both* molecules before we *do* anything with either
   #   of them.

   # We will proceed here by reading each molecule, getting the maximum cell
   #   magnitudes from each and then making the final cell cubic with sides
   #   that are a sum of those two maxima.

   # Create a directory to store the merged results in.
   mkdir ("centered");

   # Molecule 1 first
   StructureControl::readInputFile($inFile1,1);
   $mag_ref = StructureControl::getMagRef;
   @sortedMag = sort { $a <=> $b } @{$mag_ref}[1..3];
   $maxSide1 = $sortedMag[$#sortedMag];
   undef $mag_ref;

   StructureControl::reset();

   # Molecule 2 second
   StructureControl::readInputFile($inFile2,1);
   $mag_ref = StructureControl::getMagRef;
   @sortedMag = sort { $a <=> $b } @{$mag_ref}[1..3];
   $maxSide2 = $sortedMag[$#sortedMag];

   StructureControl::reset();

   # Now we can do some actual work on the molecules. Presently, the code below
   #   is in bad form because the same code is just copy-pasted for molecule 1
   #   to molecule 2. It should be another subroutine. Will FIX later.

   # Read the first olcao skeleton file and then compute the "crystal"
   #   parameters which (as a side effect) will center the molecule. (Note that
   #   the original purpose of the computeCryatalParameters was to deal with
   #   input files that do not contain lattice parameters.
   StructureControl::readInputFile($inFile1,1);
   StructureControl::setBuffer($maxSide2+$maxSide1);
   StructureControl::computeCrystalParameters;

   # Print the first molecule to a center shifted skeleton file. First we have
   #   to create a new name for the file which is just the old one with a
   #   "_cent" before the .skl. Then, we want to make sure that the system
   #   title is copied over.
   @values = split(/\./,$inFile1);
   $inFileCent1 = $values[0] . "_cent.skl";
   $systemTitle_ref = StructureControl::getSystemTitleRef;
   $systemTitle = join(@{$systemTitle_ref});
   open (SKL,">centered/$inFileCent1")
      || die "Cannot open centered/$inFileCent1 for writing.\n";
   StructureControl::printOLCAO(\*SKL,$systemTitle,"cartesian");
   close (SKL);
   undef $systemTitle_ref;

   # Reset the StructureControl data.
   StructureControl::reset();

   # Repeat the same procedure for the second molecule.

   # Read the first olcao skeleton file and then compute the "crystal"
   #   parameters which (as a side effect) will center the molecule.
   StructureControl::readInputFile($inFile2,1);
   StructureControl::setBuffer($maxSide2+$maxSide1);
   StructureControl::computeCrystalParameters;

   # Print the center shifted second molecule.
   @values = split(/\./,$inFile2);
   $inFileCent2 = $values[0] . "_cent.skl";
   $systemTitle = StructureControl::getSystemTitleRef;
   $systemTitle = join(@{$systemTitle});
   open (SKL,">centered/$inFileCent2")
      || die "Cannot open centered/$inFileCent2 for writing.\n";
   StructureControl::printOLCAO(\*SKL,$systemTitle,"cartesian");
   close (SKL);

   # Reset the StructureControl data for the next subroutine.
   StructureControl::reset();
}

sub catalogH
{
   # Define passed parameters.
   my $molNumber = $_[0];
   my $inFile = $_[1];
   my $hAtomCoords_ref = $_[2]; # Coordinates of the H atoms.
   my $bondedCoords_ref = $_[3];# Coordinates of the atoms bonded to the H atom.
   my $hAtomNumber_ref = $_[4]; # Atom number of each H atom.
   my $bondedAtomNumber_ref = $_[5]; # Atom number of the atom bonded to the H.
   my $bondedElemName_ref = $_[6]; # Element name of the atom bonded to the H.
   my $bondedSpecies_ref = $_[7]; # Species number of the atom bonded to the H.

   # Define local variables.
   my @values;
   my $atom;
   my $axis;
   my $atomTag; # A tag for an atom in the bondAnalysis file: nameType#_Atom#.
   my $bondedAtomTag; # As above except for the bonded atom.
   my $tempBondedAtomNumber; # ID number of the bonded atom.
   my $numBonds; # A temp variable for the number of bonds of an atom.
   my $directXYZ_ref;
   my $numAtoms;
   my $numHAtoms;
   my $bondFile = "bondAnalysis" . $molNumber . ".bl";

   # Read the center shifted olcao skeleton file and get data and references
   #   to key data from it.
   StructureControl::readInputFile("centered/$inFile",1);
   $numAtoms = StructureControl::getNumAtoms;
   $directXYZ_ref = StructureControl::getDirectXYZRef;

   # Request that the bond lengths between all atoms be computed.
   system("bondAnalysis -bf 1.1 -bl -i centered/$inFile -o centered/$bondFile");

   # Read the bond analysis output looking for H atoms. Then, assemble the list
   #   of the H atom coordinates and the coordinates of their bonded partner
   #   atom.
   $numHAtoms = 0; # Initialize a count of the number of H atoms in this mol.
   open (BOND,"<centered/$bondFile")
      || die "Cannot open centered/$bondFile for reading.\n";
   foreach $atom (1..$numAtoms)
   {
      # Check the tag of each atom. Read past the non-H, read the bonded atoms
      #   for the H atoms that we find.
      @values = StructureControl::prepLine(\*BOND,"",'\s+');
      $atomTag = $values[0];
      $numBonds = $values[2];
      @values = split(/[0-9]+/,$atomTag);
      if ($values[0] eq "h")
      {
         # We found a hydrogen atom.
         $numHAtoms++;

         # Make a note to the screen if there is more than one bond. We want
         #   to assume that there should be only one bond to any H atom. If
         #   there are more than one, then we will pick the closest one. There
         #   are probably other scenarios where this could be problematic so
         #   please watch out and FIX if needed.
         if ($numBonds > 1)
         {
            print STDOUT "You may have a problem with molecule 1.\n";
            print STDOUT "Atom $atomTag has more than one bond.\n";
            exit(1);
         }

         # Get the tag for the bonded atom.
         @values = StructureControl::prepLine(\*BOND,"",'\s+');
         $bondedAtomTag = $values[0]; # Form = xx##_##

         # Get the element name of the bonded atom.
         @values = split(/[0-9]/,$bondedAtomTag);
         $bondedElemName_ref->[$numHAtoms] = $values[0];

         # Get the species number of the bonded atom.
         @values = split(/[a-zA-Z_]+/,$bondedAtomTag);
         $bondedSpecies_ref->[$numHAtoms] = $values[1];

         # Get the atom number of the bonded atom.
         @values = split(/_/,$bondedAtomTag);
         $tempBondedAtomNumber = $values[1];

         # Store additional relevant information for this H-OtherAtom pair.
         foreach $axis (1..3)
         {
            $hAtomCoords_ref->[$numHAtoms][$axis]
               = $directXYZ_ref->[$atom][$axis];
            $bondedCoords_ref->[$numHAtoms][$axis]
               = $directXYZ_ref->[$tempBondedAtomNumber][$axis];
         }
         $hAtomNumber_ref->[$numHAtoms] = $atom;
         $bondedAtomNumber_ref->[$numHAtoms] = $tempBondedAtomNumber;
      }
      else # Read past bonds associated with this non-H atom. They don't matter.
      {
         foreach my $bondSet (1..ceil($numBonds/4))
            {<BOND>;}
      }
   }

   # Reset the StructureControl data for the next subroutine.
   StructureControl::reset();

   # Save the total number of atoms and number of H atoms from this molecule.
   if ($molNumber == 1)
   {
      $numAtoms1 = $numAtoms;
      $numHAtoms1 = $numHAtoms;
   }
   else
   {
      $numAtoms2 = $numAtoms;
      $numHAtoms2 = $numHAtoms;
   }

   # Close the bond analysis file.
   close(BOND);
}

## This will generate PDB files suitable for packmol from the centered molecule.
##   The trick is that one PDB will be made for every H atom in the system, with
##   the exception of scenarios where multiple H atoms bind to the same type of
##   element-species in the molecule. In those cases, the PDBs from such H atoms
##   will be identical. (I.e., they will still be made, but they will just
##   overwrite any previously made PDB files of the same kind.)
#sub generatePackmolPDBs
#{
#   # Define passed parameters.
#   my $inFileCent = $_[0];
#   my $molName = $_[1];
#   my $numAtoms = $_[2];
#   my $numHAtoms = $_[3];
#   my $bondedAtomNumber_ref = $_[4];
#   my $hAtomNumber_ref = $_[5];
#
#   # Define local variables.
#   my $line;
#   my @values;
#   my $atom;
#   my $hAtom;
#   my $sklFile;
#   my $pdbFile;
#   my $currElement;
#   my $elementSpecies;
#
#   # Open the original centered skeleton file.
#   open (MOL,"<centered/$inFileCent")
#      || die "Cannot open centered/$inFileCent for reading.\n";
#
#   # Create a PDB for each H atom in the molecule.
#   foreach $hAtom (1..$numHAtoms)
#   {
#      # Create a temporary name for the output skeleton file that will be
#      #   converted into a pdb file. The crucial difference between the temp
#      #   skeleton file and the input centered skeleton file is simply that
#      #   the temp file will have the H atom removed.
#      $sklFile = "temp.skl";
#
#      # Open the temporary skeleton file.
#      open (SKL,">centered/$sklFile")
#         || die "Cannot open centered/$sklFile for writing.\n";
#
#      # Read and copy everything from the beginning until the "cartesian" line.
#      while ($line = <MOL>)
#      {
#         if ($line =~ /^cart/)
#            {print SKL $line; last;}
#         else
#            {print SKL $line;}
#      }
#
#      # Perform a simple copy of all atoms. Also, when we find the atom that is
#      #   bonded to the H atom, make a record of the element and the species
#      #   number. That information will be used to define the output file.
#      foreach $atom (1..$numAtoms)
#      {
#         # Get the line.
#         $line = <MOL>;
#
#         # If this atom is the atom bonded to the H atom, we still print it,
#         #   but we make a note of the element and species number. Otherwise we
#         #   just print the line.
#         if ($atom == $bondedAtomNumber_ref->[$hAtom])
#         {
#            # Print the line.
#            print SKL $line;
#
#            # Get the element-species identifier.
#            @values = StructureControl::prepLine("",$line,'\s+');
#            $elementSpecies = $values[0];
#            @values = StructureControl::prepLine("",$elementSpecies,'[0-9]');
#            $currElement = $values[0];
#            @values = StructureControl::prepLine("",$elementSpecies,'[A-Za-z]');
#            $elementSpecies = $currElement . "-" . $values[0];
#         }
#         else
#            {print SKL $line;}
#      }
#
#      # Read and copy everything from the last atom to the end of the file.
#      while ($line = <MOL>)
#         {print SKL $line;}
#
#      # Close the skeleton file.
#      close (SKL);
#
#      # Reset the read pointer for the molecule file.
#      seek (MOL,0,0);
#
#      # Create the name for the PDB file on the basis of the element and
#      #   species number of the atom bonded to the H atom.
#      $pdbFile = "$molName" . "_" . "$elementSpecies.pdb";
#
#      # Convert the skeleton file to a PDB.
#      system ("skl2pdb -i centered/$sklFile -o centered/$pdbFile -skltypes");
#   }
#
#   close (MOL);
#}

sub generateMergedMols
{
   # Define local variables.
   my @values;
   my $line;
   my $axis;
   my $atom;
   my $hAtom1;
   my $hAtom2;
   my $outFile;
   my $command;
   my $found;
   my $bondedName;
   my $currBondedName;
   my @uniqueBondedNames;
   my $numUniqueBondedNames;
   my $notColinear; # A flag for signaling that a non-colinear set of atoms
                    # has been found.
   my @planeCoords; # Three points that define a plane that define a normal.
   my @rotOrigin; # The origin of the axis of rotation (an H atom).
                  # Note that this keeps the H atom in the same position.
   my @transVector1; # The point to translate the H atom of molecule 2 to for
                     # the first translation. (Coincident with H of molecule 1)
   my @transVector2; # The point to translate the H atom of molecule 2 to for
                     # the second translation. ($hhDist from H of molecule 1)
   my @finalCoord; # Third coordinate needed to define a plane. This coordinate
                   # is normally not accessible until after a translation so we
                   # have to do it manually first.
   my @diffVector1; # Difference vector used to compute the finalCoord in the
                    # event that certain atoms are colinear.
   my @diffVector2; # As above, but computing a different difference.
   my @tempVector;
   my $diff1Mag; # Magnitude of the diffVector1.
   my $diff2Mag; # Magnitude of the diffVector2.
   my $finalCoordMag; # Magnitude of the finalCoord vector.
   my $rotAngle; # Angle by which to rotate molecule 2.

   # Create a directory to store the merged results in.
   mkdir ("merged");

   # Repeatedly transform the position of molecule 2 such that every
   #   combination of the four atoms comprising a bonded atom of molecule 1,
   #   the associated H atom of molecule 1, the H atom of molecule 2, and the
   #   bonded atom of molecule 2 are all in a line in that listed order.
   # The transformation will consist of a translation, followed by a rotation,
   #   and then another a translation. All operations are applied to the
   #   coordinates of molecule 2.
   # The first translation will make the coordinates of two H atoms become
   #   coincident with each other.
   # Then, the rotation will bring the vectors defined by the lines from bonded
   #   atoms to H atoms of both molecules into anti-alignment.
   # Finally, the last translation will put the H atoms $hhDist apart.
   # The two molecules are then printed into a single "merged" file that
   #   contains all atoms.
   # This process will only be applied to unique combinations of atoms. So, for
   #   example considering some arbitrary molecule with multiple B and C atoms
   #   of various types, if the bonded atom of molecule 1 is B of type 2 and
   #   the bonded atom of molecule 2 is C of type 3 at some point in the search
   #   then the next time such a combination is detected it will not be merged.
   $numUniqueBondedNames = 0;
   foreach $hAtom1 (1..$numHAtoms1)
   {

      # Some care must be taken if (either through shear coincidence or because
      #   the molecules are the same) the H atoms and bonded atoms are
      #   co-linear with each other. That may happen easily if the two
      #   molecules are the same because we then naturally grab identical atoms.
      # If the atoms from the two molecules are colinear, then the axis of
      #   rotation cannot be defined by taking three of the atomic coordinates
      #   and using them to define a plane because they can only define a line.
      #   Thus, if such a case is detected, we will need to select a third
      #   point such that the angle of rotation is properly computed too.


      # The translation vector that will bring the two H atoms $hhDist apart
      #   from each other is the following. Note that this is a constant for
      #   each hAtom1 and its bonded pair. Note also that this is the *second*
      #   translation that will be applied although we compute this translation
      #   vector first. That is the reason that we ultimately produce the
      #   $transVector2 instead of $transVector1.
      foreach $axis (1..3)
      {
         $diffVector1[$axis] = ($hAtomCoords1[$hAtom1][$axis]
            - $bondedCoords1[$hAtom1][$axis]);
      }
      $diff1Mag = sqrt($diffVector1[1]**2
                   +   $diffVector1[2]**2
                   +   $diffVector1[3]**2);
      foreach $axis (1..3)
      {
         $diffVector1[$axis] /= $diff1Mag;
         $transVector2[$axis-1] = $diffVector1[$axis] * $hhDist;
      }

      # Iterate over all H atoms of the second molecule.
      foreach $hAtom2 (1..$numHAtoms2)
      {
         # Produce a name that identifies the atom pair bonded to the H atoms.
         $currBondedName =
               "$bondedElemName1[$hAtom1] $bondedSpecies1[$hAtom1] " .
               "$bondedElemName2[$hAtom2] $bondedSpecies2[$hAtom2]";

         # Determine if this bonded name is unique so far.
         $found = 0;
         foreach $bondedName (1..$numUniqueBondedNames)
         {
            if ($currBondedName eq $uniqueBondedNames[$bondedName])
               {$found = $bondedName; last;}
         }

         # In the event that the pair has been seen before, we go to the next.
         #   Otherwise, we record the name for future comparison.
         if ($found > 0)
            {next;}
         else
            {$uniqueBondedNames[++$numUniqueBondedNames] = $currBondedName;}


         # The translation vector that will bring the two H atoms coincident
         #   with each other is the following.
         foreach $axis (1..3)
            {$transVector1[$axis-1] = $hAtomCoords1[$hAtom1][$axis]
               - $hAtomCoords2[$hAtom2][$axis];}

         # The coordinates of the points that define a plane for the rotation
         #   are given by the atom bonded to the H atom of molecule 1, the H
         #   atom of molecule 1, and the atom bonded to the H atom of molecule
         #   2 *after* it is translated.
         # There is a tricky part here though. The position of the second
         #   bonded atom is only going to be right *after* the previous
         #   translation. We don't have that value yet, so we have to compute
         #   the translation of that atom manually just for this purpose. (Yes,
         #   we could make two separate modStruct calls, but that would be
         #   just as annoying and probably a good bit slower to execute.)
         # Also, as mentioned earlier, another somewhat tricky part is what
         #   happens if the set of three atoms are colinear. Then, we need to
         #   make the final point at some arbitrary (but non-colinear)
         #   position.

         # Compute the final coordinate assuming that the atoms are not
         #   colinear.
         foreach $axis (1..3)
            {$finalCoord[$axis] = $transVector1[$axis-1]
                                + $bondedCoords2[$hAtom2][$axis];}

         # Check if the atoms are colinear. In the event that they are, then
         #   compute a new final coordinate. To check for colinearity we will
         #   obtain normalized difference vectors between the atom bonded to
         #   the H of molecule 1 and the H atom of molecule 1 and also between
         #   the H atom of molecule 1 and the atom bonded to the H atom of
         #   molecule 2 using the coordinates it would have *after* it is
         #   translated so that the H atoms of both molecules are coincident.
         #   Then, we will compare the vector components and if none of them
         #   are different by more than epsilon we can assume that the atoms
         #   are colinear and that we need to select a different final
         #   coordiante.
         foreach $axis (1..3)
            {$diffVector2[$axis] = $hAtomCoords1[$hAtom1][$axis]
                                 - $finalCoord[$axis];}

         # Normalize the diffVector by first computing its magnitude.
         $diff2Mag = sqrt($diffVector2[1]**2
                      +   $diffVector2[2]**2
                      +   $diffVector2[3]**2);

         # Divide by the magnitude to normalize it.
         foreach $axis (1..3)
            {$diffVector2[$axis] /= $diff2Mag;}

         # Assume that the atoms *are* colinear. If the vectors differ in any
         #   direction by more than epsilon, then we say they are not colinear.
         $notColinear = 0;
         foreach $axis (1..3)
         {
            if ((abs($diffVector1[$axis])-abs($diffVector2[$axis])) > $epsilon)
               {$notColinear = 1;}
         }
         if ($notColinear == 0) # Make a new arbitrary but non-colinear coord.
         {
            # The new vector will be a unit vector that is perpendicular to the
            #   second difference vector in any direction. To do that, we first
            #   make any vector that is simply not parallel with diffVector2.
            #   The normalized cross product of that vector with diffVector2
            #   will be perpendicular to both.
            $tempVector[1] = $diffVector2[1] * 2.0; # Arbitrary 2, 3, 4
            $tempVector[2] = $diffVector2[2] * 3.0;
            $tempVector[3] = $diffVector2[3] * 4.0;
            @finalCoord = StructureControl::normalizedCrossProduct(
               \@diffVector2,\@tempVector);
         }
         @planeCoords = (@{$hAtomCoords1[$hAtom1]}[1..3],
                         @{$bondedCoords1[$hAtom1]}[1..3],
                         @finalCoord[1..3]);

         $rotAngle = StructureControl::getVectorAngle(\@diffVector2,
            \@diffVector1);
         $rotAngle = ($pi - $rotAngle) * 180.0/$pi;

         # Apply the translation, rotation, translation sequence.
         $command = "modStruct -i centered/$inFileCent2 -o centered/temp.skl "
                  . "-trans " . "@transVector1 -rotP @planeCoords -angle "
                  . "$rotAngle -orig @{$hAtomCoords1[$hAtom1]}[1..3] -trans "
                  . "@transVector2";
         system("$command");

         # The just created skeleton file can now be merged with the skeleton
         #   file of the first molecule.

         # Make the name of the merged file.
         $outFile = "olcao_" . $hAtom1 . "_" . $hAtom2 . ".skl";

         # Open both files. Then read through each and merge them into one. As
         #   we merge them, we also create PDB files of both molecules that can
         #   be used in a packmol run.
         open (MOL1,"<centered/$inFileCent1")
            || die "Cannot open centered/$inFileCent1 for reading.\n";
         open (MOL2,"<centered/temp.skl")
            || die "Cannot open centered/temp.skl for reading.\n";
         open (MERGE,">merged/$outFile")
            || die "Cannot open merged/$outFile for writing.\n";

         # Put the titles for molecules 1 and 2 into the merged file. Also
         #   print the titles for each individual molecule.
         print MERGE "title\n";
         print MERGE "MOLECULE 1\n";
         <MOL1>; # Read past the molecule 1 "title" keyword line.
         while ($line = <MOL1>)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            if ($values[0] eq 'end')
               {last;}
            else
               {print MERGE $line;}
         }
         print MERGE "MOLECULE 2\n";
         <MOL2>; # Read past the molecule 2 "title" keyword line.
         while ($line = <MOL2>)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            if ($values[0] eq 'end')
               {last;}
            else
               {print MERGE $line;}
         }
         print MERGE "end\n";

         # Copy the lattice information. Both should be identical.
         <MOL1>; # Read past "cell" of molecule 1.
         <MOL1>; # Read past the parameters (assuming a,b,c alpha,beta,gamma)
         <MOL2>; # Read past "cell" of molecule 2.
         $line = <MOL2>; # Read the parameters of molecule 2.
         print MERGE "cell\n";
         print MERGE $line;
         <MOL1>; # Read past "cartesian" in molecule 1.
         <MOL2>; # Read past "cartesian" in molecule 2.
         print MERGE "cartesian " . ($numAtoms1+$numAtoms2) . "\n";

         # Print the atoms from each molecule.
         foreach $atom (1..$numAtoms1)
         {
            $line = <MOL1>;
            print MERGE $line;
         }
         foreach $atom (1..$numAtoms2)
         {
            $line = <MOL2>;
            print MERGE $line;
         }
         print MERGE "space 1_a\n";
         print MERGE "supercell 1 1 1\n";
         print MERGE "full\n";

         close (MOL1);
         close (MOL2);
         close (MERGE);
      }
   }


   # We now want to record the maping of H atom numbers from the original
   #   molecules to the merged single molecule. The mapping from molecule 1 is
   #   very simple. It will have the same number in both files. We "overwrite"
   #   the bondedAtomNumber1 values with the atom numbers from the merged
   #   molecule, but for the atoms from molecule 1, the numbers are the same so
   #   we don't have to actually do anything.
   foreach $hAtom1 (1..$numHAtoms1)
      {$mergedHAtomNumber1[$hAtom1] = $hAtomNumber1[$hAtom1];}

   # Similarly, the mapping of H atom index numbers from the original molecule
   #   2 is also very simple. It will be the same every time with the caveat
   #   that we just have to shift the index number by the number of atoms that
   #   are in the first molecule. For the bondedAtomNumber2 we also just have
   #   to shift by the number of atoms in molecule 1.
   foreach $hAtom2 (1..$numHAtoms2)
   {
      $mergedHAtomNumber2[$hAtom2] = $hAtomNumber2[$hAtom2] + $numAtoms1;
      $bondedAtomNumber2[$hAtom2] += $numAtoms1;
   }
}

# This subroutine will read each of the merged molecule files in the "merged"
#   directory and will produce a new file for each in the "pruned" directory.
#   The new file will simply be a pruned version of the merged molecule file.
#   Pruning refers to the act of removing atoms that are a sufficient number of
#   hops (defined by the chain length variable) away from the reacting H atoms.
# One of the tasks to be executed here includes reading a bondAnalysis.bl file
#   and constructing a representation of the data contained within. This is
#   very similar to the activities used to create it in the first place and so
#   it would be nice if we could just call a subroutine in StructureControl to
#   do this for us. In the future, this subroutine should be moved into the
#   StructureControl module and it should be modified to correctly deal with
#   periodic boundary conditions. At present, this subroutine ignores that. FIX
sub pruneMergedMolecule
{
   # Define local variables
   my @values;
   my @values2;
   my $id;
   my $row;
   my $line;
   my $bond;
   my $atom;
   my $hAtom1;
   my $hAtom2;
   my $numAtoms = $numAtoms1 + $numAtoms2; # Number of atoms in the merged file
   my $atomNumber; # Index number of a particular atom.
   my $numBondRows;
   my $numBondsInRow;
   my $mergedMolFile;
   my $prunedMolFile;
   my $prunedAtomCount; # Temp indexer for maping merged to pruned hAtom number
   my $found;
   my $bondedName;
   my $currBondedName;
   my @uniqueBondedNames;
   my $numUniqueBondedNames;

   # Make a directory to hold the pruned skeleton files.
   mkdir "pruned";

   $numUniqueBondedNames = 0;
   foreach $hAtom1 (1..$numHAtoms1)
   {
      foreach $hAtom2 (1..$numHAtoms2)
      {
         # Produce a name that identifies the atom pair bonded to the H atoms.
         $currBondedName =
               "$bondedElemName1[$hAtom1] $bondedSpecies1[$hAtom1] " .
               "$bondedElemName2[$hAtom2] $bondedSpecies2[$hAtom2]";

         # Determine if this bonded name is unique so far.
         $found = 0;
         foreach $bondedName (1..$numUniqueBondedNames)
         {
            if ($currBondedName eq $uniqueBondedNames[$bondedName])
               {$found = $bondedName; last;}
         }

         # In the event that the pair has been seen before, we go to the next.
         #   Otherwise, we record the name for future comparison.
         if ($found > 0)
            {next;}
         else
            {$uniqueBondedNames[++$numUniqueBondedNames] = $currBondedName;}

         # Compute the bond analysis for this merged molecule.
         $mergedMolFile = "olcao_" . $hAtom1 . "_" . $hAtom2 . ".skl";
         system("bondAnalysis -i merged/$mergedMolFile -bl -bf 1.1");

         # Read the bondAnalysis.bl file.
         StructureControl::readBondAnalysisBL("bondAnalysis.bl",$numAtoms);

         # Get data or references to the data computed in that subroutine.
         $numBonds_ref = StructureControl::getNumBondsRef;
         $bonded_ref = StructureControl::getBondingListRef;

         # New we need to prune this molecule. We start off by assuming that no
         #   atoms will be kept and we then traverse from the current H atoms
         #   away from the other H atom.

         # Assume that no atoms are retained except for the current H atoms.
         #   Also, initialize the number of edge atoms.
         $numEdgeIDs[$hAtom1][$hAtom2] = 0;
         foreach $atom (1..$numAtoms)
            {$keepAtom[$atom] = 0;}
         $keepAtom[$mergedHAtomNumber1[$hAtom1]] = 1;
         $keepAtom[$mergedHAtomNumber2[$hAtom2]] = 1;

         # Perform a depth-first search of the data structure. Mark all atoms
         #   that are within the chain length as ones that should be kept. Note
         #   that we have to call it twice, once for each H atom with different
         #   chain lengths so that the two original molecules can be treated
         #   differently if needed. There should be no cross-over because the
         #   only place the two molecules "bond" is through the H atoms and
         #   they are initialized as keepers so that the algorithm will not
         #   attempt to "pass through" them. After the first depth-first search
         #   we have the number of pruned atoms for the first molecule and
         #   after the second depth-first search we have the total number and
         #   can compute the number of pruned atoms for the second molecule.

         # Initialize the number of pruned atoms to 2 (the two H atoms).
         $prunedNumAtoms[$hAtom1][$hAtom2] = 2;

         # Probe the first molecule.
         &markAtomsToKeep(1,$chainLen1,$mergedHAtomNumber1[$hAtom1],
            $hAtom1,$hAtom2);

         # Compute the number of atoms in the pruned first molecule.
         $prunedNumAtoms1[$hAtom1][$hAtom2] =
            $prunedNumAtoms[$hAtom1][$hAtom2] - 1; # - mol2 H

         # Probe the second molecule.
         &markAtomsToKeep(1,$chainLen2,$mergedHAtomNumber2[$hAtom2],
            $hAtom1,$hAtom2);

         # Compute the number of atoms in the pruned second molecule.
         $prunedNumAtoms2[$hAtom1][$hAtom2] =
            $prunedNumAtoms[$hAtom1][$hAtom2] -
            $prunedNumAtoms1[$hAtom1][$hAtom2];

         # At this point we can create a new "pruned" skeleton file. It will
         #   have the same name as the merged file, but it will be stored in a
         #   different directory.
         open (PRUNE,">pruned/$mergedMolFile")
            || die "Cannot open pruned/$mergedMolFile for writing.\n";

         # Open the merged file to copy from.
         open (MERGE,"<merged/$mergedMolFile")
            || die "Cannot open merged/$mergedMolFile for reading.\n";

         # Line-by-line copy the merged file over into the pruned file. Insert
         #   a new "cartesian" line and omit atom lines that were pruned.
         #   keep.
         while ($line = <MERGE>)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            if ($values[0] =~ /cartesian/)
            {
               # Print a new cartesian line with the pruned number of atoms.
               print PRUNE "cartesian $prunedNumAtoms[$hAtom1][$hAtom2]\n";

               # Go through all the atoms in the merged file and omit those
               #   that were pruned. Along the way we need to map the old
               #   H atom index number to a new pruned H atom index number.
               $prunedAtomCount = 0;
               foreach $atom (1..$numAtoms)
               {
                  $line = <MERGE>;
                  if ($keepAtom[$atom] == 1)
                  {
                     print PRUNE "$line";
                     $prunedAtomCount++;
                  }

                  # Map the index of atoms in the merged file into the pruned
                  #   file.
                  if ($atom == $mergedHAtomNumber1[$hAtom1])
                     {$prunedHAtomNumber1[$hAtom1][$hAtom2] = $prunedAtomCount;}
                  elsif ($atom == $mergedHAtomNumber2[$hAtom2])
                     {$prunedHAtomNumber2[$hAtom1][$hAtom2] = $prunedAtomCount;}
                  elsif ($atom == $bondedAtomNumber1[$hAtom1])
                     {$prunedBondedAtomNumber1[$hAtom1][$hAtom2]
                        = $prunedAtomCount;}
                  elsif ($atom == $bondedAtomNumber2[$hAtom2])
                     {$prunedBondedAtomNumber2[$hAtom1][$hAtom2]
                        = $prunedAtomCount;}
                  else
                  {
                     foreach $id (1..$numEdgeIDs[$hAtom1][$hAtom2])
                     {
                        if ($atom == $edgeID[$id][$hAtom1][$hAtom2])
                           {$prunedEdgeID[$id][$hAtom1][$hAtom2] =
                              $prunedAtomCount;}
                     }
                  }
               }
            }
            else
               {print PRUNE "$line";}
         }

         close (PRUNE);
         close (MERGE);
      }
   }
}

sub markAtomsToKeep
{
   # Define passed parameters.
   my $currentChainPoint = $_[0];
   my $maxChainLen = $_[1];
   my $currentAtom = $_[2];
   my $hAtom1 = $_[3];
   my $hAtom2 = $_[4];

   # Define local variables.
   my $bond;

   # Mark the current atom as a keeper and increment the count of the number
   #   of atoms that are kept in the pruned molecule. Note that we have to
   #   treat the special case of the first two atoms which are already 1.
   #   There should never be another case where this subroutine is called on an
   #   atom that is already 1.
   if ($keepAtom[$currentAtom] == 0)
   {
      $keepAtom[$currentAtom] = 1;
      $prunedNumAtoms[$hAtom1][$hAtom2]++;
   }

   # If the current chain point is equal to the maximum allowed chain length,
   #   then return and don't bother looking for more atoms to keep. However,
   #   before we go, we recognize that these atoms are also edge atoms and so
   #   we record them.
   if ($currentChainPoint == $maxChainLen)
   {
      $numEdgeIDs[$hAtom1][$hAtom2]++;
      $edgeID[$numEdgeIDs[$hAtom1][$hAtom2]][$hAtom1][$hAtom2] = $currentAtom;
      return 0;
   }
   else
   {
      # Consider each atom that the current atom is bonded to and call the
      #   markAtomsToKeep subroutine on each one that isn't already kept.
      foreach $bond (1..$numBonds_ref->[$currentAtom])
      {
         if ($keepAtom[$bonded_ref->[$currentAtom][$bond]] == 0)
            {&markAtomsToKeep($currentChainPoint+1,$maxChainLen,
                  $bonded_ref->[$currentAtom][$bond],$hAtom1,$hAtom2);}
      }
   }
}

# There are eight phases to a complete reaction:
#   (1) Pre  H-H bonding.  (Pre a)
#   (2) Post H-H bonding.  (Post a)
#   (3) Pre  H dissociation from molecule 1. (Pre b)
#   (4) Post H dissociation from molecule 1. (Post b)
#   (5) Pre  H dissociation from molecule 2. (Pre c)
#   (6) Post H dissociation from molecule 2. (Post c)
#   (7) Pre  Bonding between exposed atoms.  (Pre d)
#   (8) Post Bonding between exposed atoms.  (Post d)

# In the language of the LAMMPS bond_react fix, each phase is itself called a
#   "reaction". I  prefer to call (1) - (8) as separate phases of one overall
#   reaction. Please keep an eye out for miscommunications though.
#   Continuing....

# We need to make two molecule definition files for each reaction. There is a
#   pre-reaction template in which the two original molecule fragments (from
#   the pruned files) do not have any bond between them. There is also a post-
#   reaction template in which the relevant atoms bonded to the H atoms from
#   the original molecule fragments are themselves bound to each other and the
#   H atoms form a free H_2 molecule.
# Once each pair of reaction templates is created, we need to make the
#   associated map file.
#
# Pre-reaction template (a):
#
# This template will contain all atoms in the pruned file and it will contain
#   all bonds among atoms of the originally distinct molecules, but it will
#   not have any bonds that connect the two originally distinct molecules. All
#   elements (masses) and all types will be assigned as per the pruned skeleton
#   file.
#
# Post-reaction template (a):
#
# This template will contain all the same information as the pre-reaction
#   template with the addition of one more bond specifically between the H
#   atoms of the reacting molecules.
#
# Template (a) map file:
#
# All atoms in the pre-reaction template are the same as those in the post
#   reaction template. Therefore, there will be one equivalency for each atom
#   and the equivalencies will all be of the type 1 1, 2 2, 3 3, etc. The
#   bonding IDs will be the atom numbers of the two H atoms. The edge IDs will
#   be all edges that were found when pruning the molecule.
#
#
#
# Pre-reaction template (b):
#
# This template is a duplicate of the post-reaction template (a).
#
# Post-reaction template (b):
#
# This template contains all the same information as the pre-reaction template
#   (b) with the difference that it has one less bond. The bond that is removed
#   is the one between the H atom of molecule two and the atom from molecule
#   two that is bonded to that H atom.
#
# Template (b) map file:
#
# This is the same as the template (a) map file with the difference that the
#   bonding IDs are now the IDs associated with the H atom of molecule two and
#   the atom bonded to the H atom of molecule two.
#
#
#
# Pre-reaction template (c):
#
# This template is more complicated than previous ones because it does not
#   contain all atoms in the pruned skeleton file. This one contains all atoms
#   from the first molecule of the pruned skeleton file plus the H atom of the
#   second molecule. Only the bonds between the atoms of the first molecule
#   plus the H-H bond that was created in part (a) are included. The tricky
#   part is that the H atom from molecule two is not necessarily the first atom
#   in molecule two. Therefore, its ID number may not follow sequentially from
#   the last atom of molecule one. Careful accounting is required.
#
# Post-reaction template (c):
#
# This template contains all the same information as the pre-reaction template
#   (c) with the difference that it has one less bond. The bond that is removed
#   is the one between the H atom of molecule one and the atom from molecule
#   one that is bonded to that H atom. (Like the post-reaction template (b)
#   except applied to molecule one instead of molecule two. As with the
#   pre-reaction template (c), careful accounting is required to properly label
#   the H atom of molecule two and the H-H bond in which it participates.
#
# Template (c) map file:
#
# All atoms in the pre-reaction template (c) and post-reaction template (c)
#   are the same so each is listed as an equivalency. (Note: only atoms from
#   the first molecule plus the H atom of the second molecule are present.)
#   The edge IDs include only those from the first molecule plus the atom ID
#   of the H atom from the second molecule (shifted appropriately as alluded
#   to above.) The bonding IDs are the H atom of molecule one and the atom from
#   molecule one that is bonded to that H atom.
#
#
#
# Pre-reaction template (d):
#
# This template is yet more complicated. At this point the H-H molecule has
#   been separated. Thus, all atoms in the pruned skeleton file minus the two
#   H atoms will be present. Similarly, all bonds with the two molecules
#   of the pruned skeleton file except for those that bind with either of the
#   reacting H atoms will be present. As with the templates from phase (c), the
#   ID numbers of atoms will need to be carefully accounted for because both H
#   atoms from the H-H molecule will be missing. It is possible for the H from
#   the first molecule to have any ID number (it doesn't have to be the first
#   or last or whatever atom in molecule one). The same is true for the H atom
#   of molecule two.
#
# Post-reaction template (d):
#
# This template is exactly like the pre-reaction template with the addition of
#   one bond between the two atoms that were previously bonded to the two H
#   atoms that broke off to form an H-H molecule. The same counting as was used
#   for the pre-reaction template (d) will need to be used here.
#
# Template (d) map file:
#
# All atoms in the pre-reaction template (c) and post-reaction template (c)
#   are the same so each is listed as an equivalency. (Note: all atoms from the
#   pruned skeleton file except the two reacting H atoms are present.) The edge
#   IDs include all those from both molecules except for the reacting H atoms.
#   The bonding IDs are the two atoms that were bonded to the H atoms that
#   broke off to form the H-H molecule.
#
sub makeReactionTemplates
{
   # Define passed parameters
   my $rxnPhase = $_[0];

   # Define local variables.
   my $preOrPost;
   my $phaseLetter;
   my $mapFile;
   my $template;
   my $prunedMolFile;
   my $id;
   my $tag;
   my $atom;
   my $currAtom;
   my $newBondAtom1;
   my $newBondAtom2;
   my $currPhaseAtom;
   my $currMass;
   my $axis;
   my $tempTag1;
   my $tempTag2;
   my $bondTag;
   my $bond;
   my $currBond;
   my $currBondType;
   my $angle;
   my $element;
   my $hAtom1;
   my $hAtom2;
   my $bondCount;
   my $angleCount;
   my $speciesCount;
   my $numBondsTotal;
   my $atomicZ_ref;
   my $atomicMasses_ref;
   my $numAtoms;
   my @phaseAtomMap;
   my @atomPhaseMap;
   my $phaseNumAtoms;
   my $phaseNumBonds;
   my @phaseBondList;
   my $phaseNumEdgeIDs;
   my @phasePrunedEdgeID;
   my $bondingID1;
   my $bondingID2;
   my $setAtom;
   my @angleSet;
   my @bondSet;
   my $found;
   my $foundHAtom1;
   my $foundHAtom2;
   my @bondRejectSet;
   my @hhBondRejectSet;
#   my @h1BondRejectSet;
#   my @h2BondRejectSet;
   my @angleRejectSet;
   my @hhAngleRejectSet;
#   my @h1AngleRejectSet;
#   my @h2AngleRejectSet;
   my $rxnBindingPair;
   my $numOrderedSpecies;
   my @orderedSpeciesID;
   my @orderedSpeciesNames;
   my $atomElementID_ref;
   my $numSpecies_ref;
   my $bondedName;
   my $currBondedName;
   my @uniqueBondedNames;
   my $numUniqueBondedNames;
   my $elemSpecName;
   my $currElemSpecName;
   my @uniqueElemSpecNames;
   my $numUniqueElemSpecNames;

   # Create a directory to store the templates.
   mkdir "rxnTemplates";

   # Loop over all hAtom pairs.
   $numUniqueBondedNames = 0;
   foreach $hAtom1 (1..$numHAtoms1)
   {
      foreach $hAtom2 (1..$numHAtoms2)
      {
         # Produce a name that identifies the atom pair bonded to the H atoms.
         $currBondedName =
               "$bondedElemName1[$hAtom1] $bondedSpecies1[$hAtom1] " .
               "$bondedElemName2[$hAtom2] $bondedSpecies2[$hAtom2]";

         # Determine if this bonded name is unique so far.
         $found = 0;
         foreach $bondedName (1..$numUniqueBondedNames)
         {
            if ($currBondedName eq $uniqueBondedNames[$bondedName])
               {$found = $bondedName; last;}
         }

         # In the event that the pair has been seen before, we go to the next.
         #   Otherwise, we record the name for future comparison.
         if ($found > 0)
            {next;}
         else
            {$uniqueBondedNames[++$numUniqueBondedNames] = $currBondedName;}

         # Define the file name for the pruned molecule.
         $prunedMolFile = "olcao_" . $hAtom1 . "_" . $hAtom2 . ".skl";

         # Read the skeleton file and extract useful data and references.
         StructureControl::readInputFile("pruned/$prunedMolFile",1);
         $numAtoms = StructureControl::getNumAtoms;
         $directXYZ_ref = StructureControl::getDirectXYZRef;
         $atomElementName_ref = StructureControl::getAtomElementNameRef;
         $atomElementID_ref = StructureControl::getAtomElementIDRef;
         $atomSpeciesID_ref = StructureControl::getAtomSpeciesIDRef;
         $atomicZ_ref = StructureControl::getAtomicZRef;
         $numSpecies_ref = StructureControl::getNumSpeciesRef;

         # Get useful elemental information.
         $atomicMasses_ref = ElementData::getAtomicMassesRef;


         # Compute the bond length bond analysis for this pruned molecule.
         system("bondAnalysis -i pruned/$prunedMolFile -bl -bf 1.1");

         # Read the bondAnalysis.bl file.
         StructureControl::readBondAnalysisBL("bondAnalysis.bl",
            $prunedNumAtoms[$hAtom1][$hAtom2]);


         # Compute the bond angle bond analysis for this pruned molecule.
         system("bondAnalysis -i pruned/$prunedMolFile -ba -bf 1.1");

         # Read the bondAnalysis.ba file.
         StructureControl::readBondAnalysisBA("bondAnalysis.ba",
            $prunedNumAtoms[$hAtom1][$hAtom2]);

         # Get data (or references to data) obtain from the bondAnalysis file.
         $numBonds_ref = StructureControl::getNumBondsRef;
         $bonded_ref = StructureControl::getBondingListRef;
         $bondLength_ref = StructureControl::getBondLengthExtRef;
         $bondTagID_ref = StructureControl::getBondTagIDRef;
         $uniqueBondTags_ref = StructureControl::getUniqueBondTagsRef;
         $numUniqueBondTags = StructureControl::getNumUniqueBondTags;
         $numBondAngles_ref = StructureControl::getNumBondAnglesRef;
         $angleBonded_ref = StructureControl::getAngleBondedRef;
         $angleTagID_ref = StructureControl::getAngleTagIDRef;
         $numUniqueAngleTags = StructureControl::getNumUniqueAngleTags;
         $uniqueAngleTags_ref = StructureControl::getUniqueAngleTagsRef;
         $numBondsTotal = StructureControl::getNumBondsTotal;
         $numAnglesTotal = StructureControl::getNumAnglesTotal;

         # Make special variable assignments and adjustments for each phase
         #   and for each pre and post condition and map.


#         # Here we make an ordered list of the species number of all atoms that
#         #   will be in the current reaction phase template pair. The atoms are
#         #   pulled from the pruned skeleton file and the ones we don't need
#         #   are skipped. The tricky part is that the species ID number needs
#         #   to correspond to the overall system wide ID numbers. Presently,
#         #   the best we can do is the ID number from the current skeleton
#         #   file. This is corrected in the condense script when it has access
#         #   to *all* atoms in the whole model.
#         $numOrderedSpecies = 0;
         # Compute the number of atoms from the pruned pair of molecules that
         #   are needed for this phase. For each atom in the pruned model we
         #   will initially assume that it should be kept. Based on the below
         #   questions we may determine that it should not be kept. After an
         #   atom is kept, then we need to assign a type number to it and to
         #   label the type with a unique identifier. (Unique from the point of
         #   view of the pruned molecule only.)
         $numUniqueElemSpecNames = 0;
         $phaseNumAtoms = 0;
         foreach $atom (1..$numAtoms)
         {
            # Increment the number of atoms that need to be included in this
            #   phase of the reaction and also record the mapping of atoms
            #   numbers in this phase to atom number of the pruned skeleton
            #   file and vice versa.
#            $phaseAtomMap[++$phaseNumAtoms] = $atom;
#            $atomPhaseMap[$atom] = $phaseNumAtoms;
            if (($rxnPhase == 1) or ($rxnPhase == 2))
            {
               $phaseAtomMap[++$phaseNumAtoms] = $atom;
               $atomPhaseMap[$atom] = $phaseNumAtoms;
            }
            elsif (($rxnPhase == 3) or ($rxnPhase == 4))
            {
               $phaseAtomMap[++$phaseNumAtoms] = $atom;
               $atomPhaseMap[$atom] = $phaseNumAtoms;
            }
            elsif (($rxnPhase == 5) or ($rxnPhase == 6))
            {
               if (($atom <= $prunedNumAtoms1[$hAtom1][$hAtom2]) or
                   ($atom == $prunedHAtomNumber2[$hAtom1][$hAtom2]))
               {
                  $phaseAtomMap[++$phaseNumAtoms] = $atom;
                  $atomPhaseMap[$atom] = $phaseNumAtoms;
               }
               else
                  {next;} # We do not keep this atom.
            }
            else # $rxnPhase == 7 or 8
            {
               if (($atom != $prunedHAtomNumber1[$hAtom1][$hAtom2]) and
                   ($atom != $prunedHAtomNumber2[$hAtom1][$hAtom2]))
               {
                  $phaseAtomMap[++$phaseNumAtoms] = $atom;
                  $atomPhaseMap[$atom] = $phaseNumAtoms;
               }
               else
                  {next;} # We do not keep this atom.
            }

            # Create an identifier for the current atom.
            $currElemSpecName = "$atomElementName_ref->[$atom]" .
                  "$atomSpeciesID_ref->[$atom]";

            # Determine if this identifier has been seen before.
            $found = 0;
            foreach $elemSpecName (1..$numUniqueElemSpecNames)
            {
               if ($currElemSpecName eq "$uniqueElemSpecNames[$elemSpecName]")
                  {$found = $elemSpecName; last;}
            }

            # If the identifier was not found, then we record it as a new
            #   overall species number for this phase.
            if ($found == 0)
            {
               $found = ++$numUniqueElemSpecNames;
               $uniqueElemSpecNames[$found] = $currElemSpecName;
            }

            # Record the overall species ID number for this phase atom.
            $orderedSpeciesID[$phaseNumAtoms] = $found;
            $orderedSpeciesNames[$phaseNumAtoms] = $currElemSpecName;

#            # For the current $atom, go through the list of elements up to the
#            #   element of the current $atom. Accumulate a count of the species
#            #   for each of those elements. Then add on the species ID of the
#            #   current $atom. (Note, that species ID is unique *only* for a
#            #   given element, which is why we had to accumulate the count as
#            #   just described.)
#            $orderedSpeciesID[$phaseNumAtoms] = 0;
#            foreach $element (1..$atomElementID_ref->[$atom]-1)
#               {
#                  print STDOUT "atom = $atom   pNA = $phaseNumAtoms ".
#                        "numSpec[$element] = $numSpecies_ref->[$element]\n";
#                  $orderedSpeciesID[$phaseNumAtoms]+=$numSpecies_ref->[$element];}
#            $orderedSpeciesID[$phaseNumAtoms] += $atomSpeciesID_ref->[$atom];
#
#            # Get the largest number in the ordered species list. This is
#            #   equal to the number of unique species in the system.
#            if ($orderedSpeciesID[$phaseNumAtoms] > $numOrderedSpecies)
#               {$numOrderedSpecies = $orderedSpeciesID[$phaseNumAtoms];}

            # It is crucially important to realize that the ordered species ID
            #   numbers here are really only valid for the current reaction
            #   template and not the entire simulation. To make things better,
            #   it will be necessary to merge all types from all templates and
            #   from the LAMMPS data file into one unified listing. That task
            #   is reserved for the "condense" script.
         }

         # We will have to deal with this at some point. The idea is that when
         #   we break off the two H atoms and then introduce a bond between
         #   the now exposed atoms we will also want to introduce appropriate
         #   bond angles. The problem is that the full reaction occurs in four
         #   phases and tracking the angles in each will be a bit of work at
         #   the moment. For now we will just not add any bond angles. So we
         #   should expect that components that bond with each other will be
         #   a bit floppy. Hence we comment out the angle related stuff below.
         # Note that the foundHAtom1 and prunedHAtomNumber1 etc. may need to be
         #   converted to foundBonded1 and prunedBondedNumber1 etc.
#         foreach $atom (1..$numAtoms)
#         {
#            foreach $angle (1..$numBondAngles_ref->[$atom])
#            {
#               $angleSet[0] = $angleBonded_ref->[$atom][$angle][1];
#               $angleSet[1] = $atom;
#               $angleSet[2] = $angleBonded_ref->[$atom][$angle][2];
#               $foundHAtom1 = 0;
#               foreach $setAtom (0..2)
#               {
#                  if ($angleSet[$setAtom] ==
#                     $prunedHAtomNumber1[$hAtom1][$hAtom2])
#                     {$foundHAtom1 = 1; last;}
#               }
#               $foundHAtom2 = 0;
#               foreach $setAtom (0..2)
#               {
#                  if ($angleSet[$setAtom] ==
#                     $prunedHAtomNumber2[$hAtom1][$hAtom2])
#                     {$foundHAtom2 = 1; last;}
#               }
#
#               if (($foundHAtom1 == 1) and ($foundHAtom2 == 1))
#                  {push (@hhAngleRejectSet, "$atom $angle");} # PreRxn Rejects
#            }
#         }

         # Construct the list of bonds for the pre- and post-reaction templates
         #   for every phase. This must be done in two parts. In the first part
         #   we go through all known bonds and include only those that are
         #   actually needed. The first part is done via an atom-bond loop. The
         #   second part is a follow-on that explicitly adds bonds that would
         #   not otherwise be present (because they are not present in the
         #   bondAnalysis results).
         $phaseNumBonds = 0;
         foreach $atom (1..$numAtoms)
         {
            foreach $bond (1..$numBonds_ref->[$atom])
            {
               # Make certain that we don't double interact with bonds by only
               #   analyzing the case where the bonded atom has a higher index.
               if ($bonded_ref->[$atom][$bond] > $atom)
               {
                  # Depending on the particular phase we will need to count
                  #   or not count this bond. In all cases, we can only permit
                  #   bonds that bond directly to the H atom or the atom bonded
                  #   to the H atom from either molecule. That is the most
                  #   permissible criterion. In the event that this atom is
                  #   that type of bond then we will further constrain the list
                  #   according to the particular phase below. (Note that this
                  #   subroutine will also discard bonds between the molecules
                  #   regardless of the atoms involved.)
                  if (&checkBonding($atom,$bond,$hAtom1,$hAtom2) != 1)
                     {next;}

                  # Consider each phase an keep the needed bonds.
                  if (($rxnPhase >= 1) and ($rxnPhase <= 3)) # Include all bonds
                     {$phaseBondList[++$phaseNumBonds] = ["",$atom,$bond];}
                  elsif ($rxnPhase == 4)
                  {
                     # Include all bonds except the one from molecule 2 to its
                     #   H atom (or from the molecule 2 H atom to any atom in
                     #   molecule 2).
                     if ($atom == $prunedHAtomNumber2[$hAtom1][$hAtom2])
                        {last;} # Don't check any more bonds for this atom.
                     elsif ($bonded_ref->[$atom][$bond] ==
                           $prunedHAtomNumber2[$hAtom1][$hAtom2])
                        {next;}
                     else
                     {
                        # If we don't leave this block for either of the above
                        #   reasons, then we will want to keep this bond.
                        $phaseBondList[++$phaseNumBonds] = ["",$atom,$bond];
                     }
                  }
                  elsif ($rxnPhase == 5)
                  {
                     # Include only bonds from within molecule one.
                     if (($atom < $prunedNumAtoms1[$hAtom1][$hAtom2]) and
                         ($bonded_ref->[$atom][$bond] <=
                          $prunedNumAtoms1[$hAtom1][$hAtom2])) 
                        {$phaseBondList[++$phaseNumBonds] = ["",$atom,$bond];}
                  }
                  elsif ($rxnPhase == 6)
                  {
                     # Include only bonds from within molecule one, but
                     #   exclude the bond from the molecule one H atom to the
                     #   atom bonded to it from molecule one.
                     if ((($atom < $prunedNumAtoms1[$hAtom1][$hAtom2]) and
                          ($bonded_ref->[$atom][$bond] <=
                           $prunedNumAtoms1[$hAtom1][$hAtom2])) and
                         ($bonded_ref->[$atom][$bond] !=
                           $prunedHAtomNumber1[$hAtom1][$hAtom2]))
                        {$phaseBondList[++$phaseNumBonds] = ["",$atom,$bond];}
                  }
                  else # $rxnPhase == 7,8
                  {
                     # Include all bonds except any that interact with the
                     #   reacting H atoms of either molecule.
                     if (($atom == $prunedHAtomNumber1[$hAtom1][$hAtom2]) or
                         ($atom == $prunedHAtomNumber2[$hAtom1][$hAtom2]))
                        {last;} # Don't check any more bonds for this atom.
                     elsif (($bonded_ref->[$atom][$bond] ==
                          $prunedHAtomNumber1[$hAtom1][$hAtom2]) or
                         ($bonded_ref->[$atom][$bond] ==
                          $prunedHAtomNumber2[$hAtom1][$hAtom2]))
                        {next;} 
                     else
                     {
                        # If we don't leave this block for either of the above
                        #   reasons, then we will want to keep this bond.
                        $phaseBondList[++$phaseNumBonds] = ["",$atom,$bond];
                     }
                  }
               }
            }
         }


         # Add special bonds to each phase that are not expressed from the
         #   bondAnalysis results. Note that nothing needs to be done for the
         #   rxnPhase == 1 case because all bonds have already been accounted
         #   for. In the rxnPhase == 7 case certain bonds have been ignored,
         #   but we don't have to add any because the H-H does not participate.
         # Whenever a new bond is added we must account for all information
         #   associated with that bond. Note that in both cases, the starting
         #   atom is always < the ending atom so we don't have to worry about
         #   reordering. Then we must perform the following:
         # (1) Update the number of bonds that the starting atom has. That is
         #     always accomplished with a simple increment.
         # (2) Record the ending atom as the new "bonded" atom.
         # (3) Record the starting atom and the bond number in an ordered list
         #     of bonds for this phase.
         # (4) Create a tag for this bond. The tag is something like "b1 b1" or
         #     "b1 c1" or "b1 h1", or "h1 h1", etc.
         # (5) Determine if this tag is a new kind of tag or if there already
         #     exists a tag of this type. If it is new, then create the unique
         #     tag record.
         # (6) Set the ID number of the tag to the unique tag number.

         # Assume that no new bond will need to be added. Presently, it is
         #   thought that it will never be necessary to have more than one
         #   bond added in any particular case.
         $newBondAtom1 = 0;
         $newBondAtom2 = 0;

          # The H-H bond is present in phases 2, 3, 4, 5, and 6.
         if (($rxnPhase > 1) and ($rxnPhase <= 6))
         {
            $newBondAtom1 = $prunedHAtomNumber1[$hAtom1][$hAtom2];
            $newBondAtom2 = $prunedHAtomNumber2[$hAtom1][$hAtom2];
         }
         elsif ($rxnPhase == 8)
         {
            $newBondAtom1 = $prunedBondedAtomNumber1[$hAtom1][$hAtom2];
            $newBondAtom2 = $prunedBondedAtomNumber2[$hAtom1][$hAtom2];
         }

         # Perform the remaining update actions for the new bond if needed.
         if ($newBondAtom1 > 0)
         {
            # Increment the number of bonds that the first atom has.
            $numBonds_ref->[$newBondAtom1]++;

            # Record the second atom as the bonded pair of the first atom.
            $bonded_ref->[$newBondAtom1][$numBonds_ref->[$newBondAtom1]]
                  = $newBondAtom2;

            # Record the first atom and the bond number that pairs with the
            #   second atom into the bond list for this phase.
            $phaseBondList[++$phaseNumBonds] = ["",$newBondAtom1,
                  $numBonds_ref->[$newBondAtom1]];

            # Make a tag for this bond pair. It is important that the tag be
            #   alphabetical. The order of tag parts does not need to
            #   correspond to the atom order of the bond.
            $tempTag1 = "$atomElementName_ref->[$newBondAtom1]" .
                  "$atomSpeciesID_ref->[$newBondAtom1]";
            $tempTag2 = "$atomElementName_ref->[$newBondAtom2]".
                  "$atomSpeciesID_ref->[$newBondAtom2]";
            if ("$tempTag1" gt "$tempTag2")
               {$bondTag = "$tempTag2 $tempTag1";}
            else
               {$bondTag = "$tempTag1 $tempTag2";}

            # Determine if this tag already exists.
            $found = 0;
            foreach $tag (1..$numUniqueBondTags)
            {
               if ($bondTag eq $uniqueBondTags_ref->[$tag])
                  {$found = $tag;}
            }

            # If not found, then increment the number of unique bond tags and
            #   store the new unique bond tag as the last one. The bondTagID
            #   then need to reference the new unique bond tag. If the bond tag
            #   was found, then we don't have to increment the number of unique
            #   bond tags or store a new unique tag. We just set the bondTagID
            #   for this atom and bond pair to the one that was found.
            if ($found == 0)
            {
               $uniqueBondTags_ref->[++$numUniqueBondTags] = $bondTag;
               $bondTagID_ref->[$newBondAtom1][$numBonds_ref->[$newBondAtom1]]
                     = $numUniqueBondTags;
            }
            else
            {
               $bondTagID_ref->[$newBondAtom1][$numBonds_ref->[$newBondAtom1]]
                     = $found;
            }
         }


         # At this point we can define the bonding pair for the map file.
         if ($rxnPhase == 1)
         {
            $bondingID1 = $atomPhaseMap[$prunedHAtomNumber1[$hAtom1][$hAtom2]];
            $bondingID2 = $atomPhaseMap[$prunedHAtomNumber2[$hAtom1][$hAtom2]];
         }
         elsif ($rxnPhase == 3)
         {
            $bondingID1 =
               $atomPhaseMap[$prunedHAtomNumber2[$hAtom1][$hAtom2]];
            $bondingID2 =
               $atomPhaseMap[$prunedBondedAtomNumber2[$hAtom1][$hAtom2]];
         }
         elsif ($rxnPhase == 5)
         {
            $bondingID1 = $atomPhaseMap[$prunedHAtomNumber1[$hAtom1][$hAtom2]];
            $bondingID2 =
               $atomPhaseMap[$prunedBondedAtomNumber1[$hAtom1][$hAtom2]];
         }
         elsif ($rxnPhase == 7)
         {
            $bondingID1 =
               $atomPhaseMap[$prunedBondedAtomNumber1[$hAtom1][$hAtom2]];
            $bondingID2 =
               $atomPhaseMap[$prunedBondedAtomNumber2[$hAtom1][$hAtom2]];
         }


         # Construct the edge IDs specific to each phase.
         if (($rxnPhase == 1) or ($rxnPhase == 3))
         {
            # All edge IDs obtained earlier will be used. No edge ID will be
            #   added or subtracted.
            $phaseNumEdgeIDs = $numEdgeIDs[$hAtom1][$hAtom2];
            foreach $id (1..$phaseNumEdgeIDs)
               {$phasePrunedEdgeID[$id] =
                $atomPhaseMap[$prunedEdgeID[$id][$hAtom1][$hAtom2]];}
         }
         elsif ($rxnPhase == 5)
         {
#            # All edge IDs obtained earlier will be used. No edge ID will be
#            #   added or subtracted.
#            $phaseNumEdgeIDs = $numEdgeIDs[$hAtom1][$hAtom2];
#            foreach $id (1..$phaseNumEdgeIDs)
#               {$phasePrunedEdgeID[$id] =
#                $atomPhaseMap[$prunedEdgeID[$id][$hAtom1][$hAtom2]];}
            # Only edge IDs for molecule one will be used plus one more edge ID
            #   which is the H atom of molecule 2.
            $phaseNumEdgeIDs = 0;
            foreach $id (1..$numEdgeIDs[$hAtom1][$hAtom2])
            {
               if ($prunedEdgeID[$id][$hAtom1][$hAtom2] <=
                   $atomPhaseMap[$prunedNumAtoms1[$hAtom1][$hAtom2]])
               {
                  $phasePrunedEdgeID[++$phaseNumEdgeIDs] =
                     $atomPhaseMap[$prunedEdgeID[$id][$hAtom1][$hAtom2]];
               }
            }

            # Add the H atom from the second molecule as the last edge ID.
            $phasePrunedEdgeID[++$phaseNumEdgeIDs] =
               $atomPhaseMap[$prunedHAtomNumber2[$hAtom1][$hAtom2]];
         }
         elsif ($rxnPhase == 7)
         {
            # All edge IDs obtained earlier will be used except for the
            #   reacting H atoms of each molecule.
            $phaseNumEdgeIDs = 0;
            foreach $id (1..$numEdgeIDs[$hAtom1][$hAtom2])
            {
               if (($prunedEdgeID[$id][$hAtom1][$hAtom2] !=
                    $prunedHAtomNumber1[$hAtom1][$hAtom2]) and
                   ($prunedEdgeID[$id][$hAtom1][$hAtom2] !=
                    $prunedHAtomNumber2[$hAtom1][$hAtom2]))
                  {$phasePrunedEdgeID[++$phaseNumEdgeIDs] =
                   $atomPhaseMap[$prunedEdgeID[$id][$hAtom1][$hAtom2]];}
            }
         }

         # Make the actual adjustments and finalize the needed data structures.
         # Define the unique file name component.
         $rxnBindingPair =
            $atomElementName_ref->
               [$prunedBondedAtomNumber1[$hAtom1][$hAtom2]] ."-".
            $atomSpeciesID_ref->
               [$prunedBondedAtomNumber1[$hAtom1][$hAtom2]] ."_".
            $atomElementName_ref->
               [$prunedBondedAtomNumber2[$hAtom1][$hAtom2]] ."-".
            $atomSpeciesID_ref->[$prunedBondedAtomNumber2[$hAtom1][$hAtom2]];

         # Define the various file names:
         $phaseLetter = chr(ord('a') + int(($rxnPhase-1)/2));
         if ($rxnPhase/2 != int($rxnPhase/2))
            {$preOrPost = "preRxn";}
         else
            {$preOrPost = "postRxn";}

         $mapFile = "$rxnBindingPair.$phaseLetter.map";
         $template = "$preOrPost.$rxnBindingPair.$phaseLetter.data";

         # Open the pre or post-reaction molecule template for this hh pair.
         open (OUT,">rxnTemplates/$template")
            || die "Cannot open rxnTemplates/$template for writing.\n";

         print OUT "$template\n\n";

         print OUT "$phaseNumAtoms atoms\n";
         print OUT "$phaseNumBonds bonds\n";
         print OUT "0 angles\n";
#         print OUT "$numAnglesTotal angles\n"; # FIX if needed.
         print OUT "0 dihedrals\n";
         print OUT "0 impropers\n";

         print OUT "\nMasses\n\n";

         foreach $atom (1..$phaseNumAtoms)
         {
            $currMass = $atomicMasses_ref->
               [$atomicZ_ref->[$phaseAtomMap[$atom]]];
            print OUT "$atom $currMass\n";
         }

# Seems to not be needed. I imagine that it forces a requirement that the
#   molecule must be at a specific site before the reaction can occur. Without
#   this given then the only thing that is studied is the bond topology. The
#   true atomic positional topology is not used.
#         print OUT "\nCoords\n\n";
#
#         foreach $atom (1..$prunedNumAtoms[$hAtom1][$hAtom2])
#         {
#            print OUT "$atom";
#            foreach $axis (1..3)
#               {print OUT " $directXYZ_ref->[$atom][$axis]";}
#            print OUT "\n";
#         }

         print OUT "\nTypes\n\n";

         foreach $atom (1..$phaseNumAtoms)
         {
            print OUT "$atom $orderedSpeciesID[$atom] ".
               "# $orderedSpeciesNames[$atom]\n";
         }

         print OUT "\nBonds\n\n";

         $bondCount = 0;
         foreach $bond (1..$phaseNumBonds)
         {
            $currAtom = $phaseBondList[$bond][1];
            $currBond = $phaseBondList[$bond][2];
            $currBondType = $bondTagID_ref->[$currAtom][$currBond];
            $currPhaseAtom = $atomPhaseMap[$currAtom];
            print OUT "$bond $currBondType $currPhaseAtom " .
               "$atomPhaseMap[$bonded_ref->[$currAtom][$currBond]] # " .
               "$uniqueBondTags_ref->[$currBondType]\n";
         }

         close (OUT);

         # Create the map file. We only need one for each phase of the overall
         #   reaction so we make it when we are doing (arbitrarily) the
         #   pre-reaction cases.
         if ($rxnPhase/2 != int($rxnPhase/2))
         {
            open (MAP,">rxnTemplates/$mapFile")
                  || die "Cannot open rxnTemplates/$mapFile for writing\n";
            print MAP "# Map file: $mapFile\n\n";
            print MAP "$phaseNumEdgeIDs edgeIDs\n";
            print MAP "$phaseNumAtoms equivalences\n\n";

            print MAP "BondingIDs\n\n";
            print MAP "$bondingID1\n";
            print MAP "$bondingID2\n\n";

            print MAP "EdgeIDs\n\n";
            foreach $id (1..$phaseNumEdgeIDs)
               {print MAP "$phasePrunedEdgeID[$id]\n";}
            print MAP "\nEquivalences\n\n";
            foreach $id (1..$phaseNumAtoms)
               {print MAP "$id $id\n";}
            close (MAP);
         }
      }
   }
}

# This subroutine will determine whether or not a particular bond includes one
#   of the H atoms or the atom bonded to the H atoms. Only those types of bonds
#   can be included. (I.e., we want to avoid the case of included in the bond
#   list a bond that is between two edge atoms. That will cause the bond_react
#   fix to not work.)
sub checkBonding
{
   # Define passed parameters.
   my $atom = $_[0];
   my $bond = $_[1];
   my $hAtom1 = $_[2];
   my $hAtom2 = $_[2];

   # Make sure that we never include any bond between molecule 1 and molecule
   #   2. The two molecules should be placed "far enough" apart that they
   #   never have bonds between them. (Including between the H atoms.) However,
   #   just to be certain, we do this check. 
   if (($atom <= $prunedNumAtoms1[$hAtom1][$hAtom2]) and
       ($bonded_ref->[$atom][$bond] > $prunedNumAtoms1[$hAtom1][$hAtom2]))
      {return 0;}

   # Permit the bond if the atom is any one of: H atom from molecule 1 or 2; or
   #   the atom bonded to the H atom from molecule 1 or 2.
   if (($atom == $prunedHAtomNumber1[$hAtom1][$hAtom2]) or
       ($atom == $prunedHAtomNumber2[$hAtom1][$hAtom2]) or
       ($atom == $prunedBondedAtomNumber1[$hAtom1][$hAtom2]) or
       ($atom == $prunedBondedAtomNumber2[$hAtom1][$hAtom2]))
      {return 1;}

   # Permit the bond if the bonded atom is any one of the same set from above.
   if (($bonded_ref->[$atom][$bond] == $prunedHAtomNumber1[$hAtom1][$hAtom2]) or
       ($bonded_ref->[$atom][$bond] == $prunedHAtomNumber2[$hAtom1][$hAtom2]) or
       ($bonded_ref->[$atom][$bond]
          == $prunedBondedAtomNumber1[$hAtom1][$hAtom2]) or
       ($bonded_ref->[$atom][$bond]
          == $prunedBondedAtomNumber2[$hAtom1][$hAtom2]))
      {return 1;}

   # In the event that we got here, then we must have a bond that goes between
   #   two "deeper" atoms in one of the molecules (e.g., between two edge
   #   atoms). We cannot permit this because it seems that the bond_react fix
   #   in LAMMPS does not like it (maybe because it forms a loop?).
   return 0;
}

sub addBondAngles
{
   # Define passed parameters.
   my $bondedAtomNumberA = $_[0];  # Use A,B to avoid confusion with 1,2.
   my $bondedAtomNumberB = $_[1];  # Same

   # Define local variables.
   my $tag;
   my $axis;
   my $bond;
   my $a;
   my $b;
   my $c;
   my $neighborAtom;
   my $currentAtom;
   my $sqrDiff;
   my $gamma;
   my $cosGamma;
   my $angleTag;
   my $angleTag1;
   my $angleTag2;
   my $atomV;
   my $atom1;
   my $atom2;
   my $atomTemp;
   my $angle;
   my $decimal;
   my $found;

   $neighborAtom = $bondedAtomNumberA;

   # In every one of the new bond angles, one of the non-vertex atoms
   #   will be the neighbor to the $hAtom2 atom. We will need to know the
   #   distance to that atom and we don't have it yet so we compute it
   #   first.
   $sqrDiff = 0;
   foreach $axis (1..3)
   {
      $sqrDiff +=
        ($directXYZ_ref->[$neighborAtom][$axis] -
         $directXYZ_ref->[$bondedAtomNumberB][$axis])**2;
   }
   $b = sqrt($sqrDiff);

   # Now we can compute the rest of the bond angle data that is dependent
   #   on each of the bonds to the neighbor of the vertex $hAtom atom.
   foreach $bond (1..$numBonds_ref->[$neighborAtom])
   {
      $currentAtom = $bonded_ref->[$neighborAtom][$bond];

      # Get the distance between the vertex and its bond
      $a = $bondLength_ref->[$neighborAtom][$bond];

      # Compute the distance between the $a and the $b atoms.
      $sqrDiff = 0;
      foreach $axis (1..3)
      {
         $sqrDiff +=
           ($directXYZ_ref->[$currentAtom][$axis] -
            $directXYZ_ref->[$bondedAtomNumberB][$axis])**2;
      }
      $c = sqrt($sqrDiff);

      # Apply the law of cosines: c^2 = a^2 + b^2 - 2ab cos(gamma) to
      #   solve for gamma (the angle between the bonds) where c is the
      #   distance between the two bonded atoms, a is the distance
      #   from the central (vertex) atom to one bonded atom and b is
      #   the distance from the vertex to the other.
      $cosGamma = ($a*$a + $b*$b - $c*$c)/(2.0*$a*$b);
      if ($cosGamma > 1.0)
      {
         if (abs($cosGamma - 1.0) < $epsilon)
            {$gamma = 0;}
         else
            {die "Atomic coords give unrealistic cos magnitude: $cosGamma\n";}
      }
      elsif ($cosGamma < -1.0)
      {
         if (abs($cosGamma + 1.0) < $epsilon)
            {$gamma = $pi;}
         else
            {die "Atomic coords give unrealistic cos magnitude: $cosGamma\n";}
      }
      else
         {$gamma = &acos(($a*$a + $b*$b - $c*$c)/(2.0*$a*$b));}
      $gamma *= 180.0/$pi; # Convert to degrees.

      # Round to the nearest integer or half-integer. This rounding scheme is
      #   fairly non-standard and it really only works for positive quantities.
      $decimal = StructureControl::remainder(1,$gamma);
      if (($decimal < 0.75) or ($decimal > 0.25))
         {$gamma = int($gamma) + 0.5;}
      else
         {$gamma = int($gamma + 0.5);}

      # Add the bond angle. We have to get the atom number of each atom that is
      #   participating in the bond angle. We also have to assemble the angle
      #   tag and check if it is unique among all the known angle tags. If it
      #   is unique, then we add it to the list of known tags. If it isn't,
      #   then do nothing.
      # Note that this angle is added to the list of bond angles that have the
      #   current $neighborAtom as a vertex.

      # Get the atom number of the vertex atom, the smaller index atom number,
      #   and the larger index atom number.
      $atomV = $neighborAtom;
      $atom1 = $currentAtom;
      $atom2 = $bondedAtomNumberB;
      if ($atom1 > $atom2)
      {
         $atomTemp = $atom1;
         $atom1 = $atom2;
         $atom2 = $atomTemp;
      }

      # Increment the number of bond angles for this vertex atom.
      $numBondAngles_ref->[$atomV]++;

      # Get the angle number of this angle in the list of angles that have
      #   neighborAtom as the vertex. We need it later if we have to add an
      #   ID tag.
      $angle = $numBondAngles_ref->[$atomV];

      # Create the trial angle tags for this triplet.
      $angleTag1 =
         $atomElementName_ref->[$atom1] . $atomSpeciesID_ref->[$atom1] . " " .
         $atomElementName_ref->[$atomV] . $atomSpeciesID_ref->[$atomV] . " " .
         $atomElementName_ref->[$atom2] . $atomSpeciesID_ref->[$atom2] . " " .
         $gamma;
      $angleTag2 =
         $atomElementName_ref->[$atom2] . $atomSpeciesID_ref->[$atom2] . " " .
         $atomElementName_ref->[$atomV] . $atomSpeciesID_ref->[$atomV] . " " .
         $atomElementName_ref->[$atom1] . $atomSpeciesID_ref->[$atom1] . " " .
         $gamma;

      # Search for the angle tag among all known tags.
      $found = 0;
      foreach $tag (1..$numUniqueAngleTags)
      {
         if ($angleTag1 eq $uniqueAngleTags_ref->[$tag])
            {$found = $tag; $angleTag = $angleTag1; last;}
         elsif ($angleTag2 eq $uniqueAngleTags_ref->[$tag])
            {$found = $tag; $angleTag = $angleTag2; last;}
      }
      if ($found == 0)
      {
         # Create an angle tag that follows the form of $angleTag1. Any unfound
         #   angle will either be one of the original pre-reaction angles that
         #   certainly will follow the $angleTag1 form or will be an angle
         #   added after the bonding reaciton. In the second case, the form of
         #   $angleTag1 will *define* the correct name for the angle.
         $angleTag = $angleTag1;
         $numUniqueAngleTags++;
         $angleTagID_ref->[$atomV][$angle] = $numUniqueAngleTags;
         $uniqueAngleTags_ref->[$numUniqueAngleTags] = $angleTag;
      }
      else
         {$angleTagID_ref->[$atomV][$angle] = $found;}

      # Store the atom numbers for this bond angle.
      $angleBonded_ref->[$atomV][$angle][1] = $atom1;
      $angleBonded_ref->[$atomV][$angle][2] = $atom2;

      # Increment the total count of the number of bond angles
      $numAnglesTotal++;
   }
}

sub addBond
{
   # Define passed parameters.
   my $bondedAtomNumberA = $_[0]; # Use A,B to avoid confusion with 1,2.
   my $bondedAtomNumberB = $_[1]; # Same.

   # Define local parameters.
   my $tag;
   my $bondTag;
   my $found;
   my $tempAtom;
   my $numBondsA;

   # Make sure that the A atom is the lower index number.
   if ($bondedAtomNumberA > $bondedAtomNumberB)
   {
      $tempAtom = $bondedAtomNumberA;
      $bondedAtomNumberA = $bondedAtomNumberB;
      $bondedAtomNumberB = $tempAtom;
   }

   # Increment the number of bonds for this atom.
   $numBonds_ref->[$bondedAtomNumberA]++;
   $numBondsA = $numBonds_ref->[$bondedAtomNumberA];

   # Store the index number of the atom bonded to A (which is B).
   $bonded_ref->[$bondedAtomNumberA][$numBonds_ref->[$bondedAtomNumberA]] =
      $bondedAtomNumberB;

   # Create the tag for this atom pair.
   $bondTag = $atomElementName_ref->[$bondedAtomNumberA]
      . $atomSpeciesID_ref->[$bondedAtomNumberA] . " "
      . $atomElementName_ref->[$bondedAtomNumberB]
      . $atomSpeciesID_ref->[$bondedAtomNumberB];

   # Determine if this is a unique type of bond or if not, which one it is.
   $found = 0;
   foreach $tag (1..$numUniqueBondTags)
   {
      if ($bondTag eq $uniqueBondTags_ref->[$tag])
         {$found = $tag; last;}
   }

   # If it is unique, then add it to the list of known bond tags. Otherwise,
   #   just record the ID that this bond matches.
   if ($found == 0)
   {
      $numUniqueBondTags++;
      $bondTagID_ref->[$bondedAtomNumberA][$numBondsA] = $numUniqueBondTags;
      $uniqueBondTags_ref->[$numUniqueBondTags] = $bondTag;
   }
   else
      {$bondTagID_ref->[$bondedAtomNumberA][$numBondsA] = $found;}

   # The total number of bonds in the system has already been adjusted before
   #   this subroutine was called.
}
